<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on chamilad.github.io</title>
    <link>https://chamilad.github.io/tags/python/</link>
    <description>Recent content in Python on chamilad.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Dec 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://chamilad.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BreadPool — a Thread Pool for Python</title>
      <link>https://chamilad.github.io/post/2015-12-10_breadpool-a-thread-pool-for-python/</link>
      <pubDate>Thu, 10 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chamilad.github.io/post/2015-12-10_breadpool-a-thread-pool-for-python/</guid>
      <description>A thread pool is not a new concept. It’s basically a gang of worker threads to whom a task would be given to be executed. Why thread pools? Because the program wouldn’t be starting threads as it sees fit and somehow reach the maximum thread number soon. Simply said thread pools allows us to limit the number of threads spawned by our program execution. Trust me, you don’t want your code going to town spawning threads.</description>
    </item>
    
    <item>
      <title>Timing Out of Long Running Methods in Python</title>
      <link>https://chamilad.github.io/post/2015-11-26_timing-out-of-long-running-methods-in-python/</link>
      <pubDate>Thu, 26 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chamilad.github.io/post/2015-11-26_timing-out-of-long-running-methods-in-python/</guid>
      <description>Sometimes there are conditions under which a function call could not return in a needed time period and would cause unexpected behavior. For example, a file read could take more time than anticipated and leave the code execution without proper control over what to do when such a situation occurs. This can be worse if the said function call directs to an external library which we can’t control.
Python has a nifty module called signal which exposes UNIX Signal numbers and a way to register callbacks for each signal.</description>
    </item>
    
    <item>
      <title>Apache Stratos Cartridge Agent: Day 0</title>
      <link>https://chamilad.github.io/post/2015-03-17_apache-stratos-cartridge-agent-day-0/</link>
      <pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chamilad.github.io/post/2015-03-17_apache-stratos-cartridge-agent-day-0/</guid>
      <description>As the first post of a series of comprehensive guide to the Apache Stratos Cartridge Agent, let’s look at the Cartridge Agent contract. Keep tuned in and expect more detailed explanations on the instance and Cartridge Agent configuration, workflow, different Cartridge Agent implementations, their configurations and newly introduced plugin system in the Python implementation.
When the instances are spawned in Apache Stratos, there are a few requirements that the particular instance should fulfill.</description>
    </item>
    
  </channel>
</rss>