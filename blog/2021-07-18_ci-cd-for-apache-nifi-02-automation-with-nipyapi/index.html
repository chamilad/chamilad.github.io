<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.92.2" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://chamila.dev/blog/2021-07-18_ci-cd-for-apache-nifi-02-automation-with-nipyapi/" />
  <link rel="canonical" href="https://chamila.dev/blog/2021-07-18_ci-cd-for-apache-nifi-02-automation-with-nipyapi/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/chamila.dev\/"
      },
      "articleSection" : "blog",
      "name" : "CI\/CD for Apache Nifi 02: Automation with NipyAPI",
      "headline" : "CI\/CD for Apache Nifi 02: Automation with NipyAPI",
      "description" : "Wharf on a good day   In the earlier post on setting up Apache Nifi and Nifi Registry, two Nifi and Registry deployments set up and integrated with each other. This post will focus on automating the migrations between the two environments. Just to refresh, the following diagram shows what we are trying to achieve.\n Though this shows three environments, we have only taken the dev -\u0026gt; test step into consideration in the current and the previous posts.",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2021",
      "datePublished": "2021-07-18 22:20:47 \u002b1200 NZST",
      "dateModified" : "2021-07-18 22:20:47 \u002b1200 NZST",
      "url" : "https:\/\/chamila.dev\/blog\/2021-07-18_ci-cd-for-apache-nifi-02-automation-with-nipyapi\/",
      "keywords" : [ "Apache Nifi","Data Transformation","BigData", ]
  }
</script>
<title>CI/CD for Apache Nifi 02: Automation with NipyAPI - chamila.dev</title>
  <meta property="og:title" content="CI/CD for Apache Nifi 02: Automation with NipyAPI - chamila.dev" />
  <meta property="og:type" content="article" />
  <meta name="description" content="Wharf on a good day   In the earlier post on setting up Apache Nifi and Nifi Registry, two Nifi and Registry deployments set up and integrated with each other. This post will focus on automating the migrations between the two environments. Just to refresh, the following diagram shows what we are trying to achieve.
 Though this shows three environments, we have only taken the dev -&gt; test step into consideration in the current and the previous posts." />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link rel="stylesheet" href="/css/light.css">
  <link rel="stylesheet" href="/css/dark.css">
  <link href="/blog/index.xml" rel="alternate" type="application/rss+xml" title="chamila.dev">

  <link href="/fa/css/all.css" rel="stylesheet">

  
  
  
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  

</head>


<body class="theme-light">
  <article class="post " id="article">
    <div class="row">
      <div class="container col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div id="floating-menu-wrapper">
  <div id="floating-menu">
    <button id="switch-to-dark">
      <i class="fas fa-moon"></i>
    </button>
    <button id="switch-to-light" class="current-theme">
      <i class="fas fa-sun"></i>
    </button>
  </div>
</div>

        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <span class="breadcrumbs">
      <a href="https://chamila.dev/">chamila.dev</a> >
      <a href="https://chamila.dev//blog"> journal </a> >
    </span>
    <div class="sm-icons">
  <a href="https://chamila.dev//blog/index.xml" target="_blank" title="rss">
    <i class="fas fa-rss sm-icon"></i>
  </a>
  <a href="https://github.com/chamilad" target="_blank" title="github">
    <i class="fab fa-github sm-icon"></i>
  </a>
  <a href="https://fosstodon.org/@chamilad" target="_blank" title="fosstodon" rel="me">
    <i class="fab fa-mastodon sm-icon"></i>
  </a>
</div>

  </div>
</header>
<div class="row end-xs">
   
</div>


        </div>
        <header class="post-header">
          <h1 class="post-title">CI/CD for Apache Nifi 02: Automation with NipyAPI</h1>
          
          <div class="row post-desc">
            <div class="pub-date col-xs-6">
              
              <time class="post-date" datetime=" 2021-07-18 22:20:47 NZST">
                18 Jul 2021
              </time>
              
            </div>
            <div class="reading-time col-xs-6" title="approximate read time">
              ~14 minutes
            </div>
            
            
            
          </div>
          
          <div class="toc">
            
            <h4>Table of Contents:</h4>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#exporting-process-groups">Exporting Process Groups</a>
      <ul>
        <li><a href="#connecting-to-the-dev-environment">Connecting to the <code>dev</code> environment</a></li>
        <li><a href="#which-ones">Which ones?</a></li>
        <li><a href="#staging-for-migration">Staging for migration</a></li>
      </ul>
    </li>
    <li><a href="#importing-back-to-test-environment">Importing back to <code>test</code> environment</a>
      <ul>
        <li><a href="#connecting-to-the-test-environment">Connecting to the <code>test</code> environment</a></li>
        <li><a href="#registry-bucket">Registry Bucket</a></li>
        <li><a href="#extra-checks">Extra checks</a></li>
        <li><a href="#parameter-contexts">Parameter Contexts</a></li>
        <li><a href="#create-or-update">Create or Update?</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#end-results">End results</a></li>
    <li><a href="#quirks">Quirks?</a>
      <ul>
        <li><a href="#with-the-design">With the design</a></li>
        <li><a href="#with-the-script">With the script</a></li>
      </ul>
    </li>
  </ul>
</nav>
            
          </div>
        </header>
        <div class="post-content markdown-body">
          <figure><img src="/blog/img/2021-07-18_nifi_cicd_02_header.jpeg"/><figcaption>
            <h4>Wharf on a good day</h4>
        </figcaption>
</figure>

<p>In the <a href="/post/2021-07-17_ci-cd-for-apache-nifi-01-intro-and-setup/">earlier post on setting up Apache Nifi and Nifi Registry</a>, two Nifi and Registry deployments set up and integrated with each other. This post will focus on automating the migrations between the two environments. Just to refresh, the following diagram shows what we are trying to achieve.</p>
<p><img src="/blog/img/2021-07-17_nifi_cicd_design.png" alt="CI/CD design for Nifi"></p>
<blockquote>
<p>Though this shows three environments, we have only taken the <code>dev</code> -&gt; <code>test</code> step into consideration in the current and the previous posts. This is because once you automate the series of steps, it&rsquo;s just a matter of pointing the script to the next step.</p>
</blockquote>
<h1 id="introduction">Introduction</h1>
<p>Both Nifi and the Nifi Registry expose RESTful APIs that can be communicated with through HTTP. However, it&rsquo;s far easier to work with an API when a good SDK is available. In Nifi&rsquo;s case, this is <a href="https://nipyapi.readthedocs.io/en/latest/readme.html">NipyAPI</a>. NipyAPI SDK has built-in methods to work with both of the products and is has good documentation that makes the whole exercise a pleasant experience.</p>
<p>In terms of what we want automated, the series of actions we want to focus on are the following.</p>
<ol>
<li>Export a set of Process Groups from <code>dev</code> environment</li>
<li>Import the Process Groups back to the <code>test</code> environment</li>
</ol>
<p>They look pretty simple, however there are more considerations in each of these steps.</p>
<h1 id="implementation">Implementation</h1>
<h2 id="exporting-process-groups">Exporting Process Groups</h2>
<h3 id="connecting-to-the-dev-environment">Connecting to the <code>dev</code> environment</h3>
<p>Before we do anything, we need to point the SDK to the <code>dev</code> environment. We do this by using the <code>util.set_endpoint()</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">import</span> nipyapi

<span style="color:#007f7f">#...</span>
<span style="color:#007f7f">#...</span>

<span style="color:#007f7f"># just to keep the logs simple</span>
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

<span style="color:#007f7f"># disable TLS check, do at your own risk</span>
nipyapi.config.nifi_config.verify_ssl = <span style="color:#fff;font-weight:bold">False</span>
nipyapi.config.registry_config.verify_ssl = <span style="color:#fff;font-weight:bold">False</span>

<span style="color:#007f7f"># connect to Nifi</span>
nipyapi.utils.set_endpoint(<span style="color:#0ff;font-weight:bold">&#34;https://localhost:8443/nifi-api&#34;</span>)
<span style="color:#007f7f"># wait for connection to be set up</span>
connected = nipyapi.utils.wait_to_complete(
    test_function=nipyapi.utils.is_endpoint_up,
    endpoint_url=<span style="color:#0ff;font-weight:bold">&#34;https://localhost:8443/nifi&#34;</span>,
    nipyapi_delay=nipyapi.config.long_retry_delay,
    nipyapi_max_wait=nipyapi.config.short_max_wait
)

<span style="color:#007f7f"># connect to Nifi Registry</span>
nipyapi.utils.set_endpoint(<span style="color:#0ff;font-weight:bold">&#34;http://localhost:18080/nifi-registry-api&#34;</span>)
connected = nipyapi.utils.wait_to_complete(
    test_function=nipyapi.utils.is_endpoint_up,
    endpoint_url=<span style="color:#0ff;font-weight:bold">&#34;http://localhost:18080/nifi-registry&#34;</span>,
    nipyapi_delay=nipyapi.config.long_retry_delay,
    nipyapi_max_wait=nipyapi.config.short_max_wait
)

</code></pre></div><p>The method <code>util.wait_to_complete()</code> is an interesting one. As you can see, it allows a blocking operation that waits for a given endpoint to be up and available, so technically, the script can start execution before the Nifi and Registry instances are up and ready to receive requests.</p>
<blockquote>
<p>Note that the APIs for each of the components are available at the <code>-api</code> suffix application, not at the Web application.</p>
</blockquote>
<h3 id="which-ones">Which ones?</h3>
<p>We ended the previous post by committing the sample Process Group <code>RandomEvents</code> to version control. However, in a real world scenario there would be multiple, tens of Process Groups in Nifi to be managed. While you can list all the top level Process Groups on the Canvas (the Canvas is the Nifi visual editor UI presented to the user when visiting the Web Console), you may not necessarily want to do that, especially on a <code>dev</code> environment, where different Data Engineers would be working on Process Groups at different states.</p>
<p><img src="/blog/img/2021-07-17_nifi_cicd_example.png" alt="RandomEvents Process Group"></p>
<p>A better way to do this is to define a list of Process Groups to be migrated. The script can then lookup the presence of each of the names and export them separately, rather than collecting all the Process Groups across the Canvas.</p>
<p>This can be improved (or depending on your view, made complex) by adding another dimension to the Process Group name input. You can also make it so that the version that should exported for each Process Group is also defined in the input. This would be useful, when it&rsquo;s required to allow development to progress without waiting on delivery to happen at the same pace. Data Engineers could implement certain changes, commit to the Registry, and continue implementing breaking changes, and when the time to roll out the earlier changes to <code>test</code> comes, the older version can be specified for each Process Group so that the script would only export those versions, and not the <code>latest</code>.</p>
<h3 id="staging-for-migration">Staging for migration</h3>
<p>When exporting, the script will do so from the Registry, not from Nifi. These are two different components, two different binaries, and two different APIs. Because of this, when you request exports from the Registry, you will get the latest version for the specified Flow (or a specified version).</p>
<p>However, if the specific Process Group is not committed to version control, the Registry will not know about it. So it makes sense, from automation perspective, to do a check that the Process Group is committed to version control on the Canvas.</p>
<p>Furthermore, there could be uncommitted changes on the Nifi Canvas, that may have been missed from being added to version control. We can check this using the Nifi API, just to make sure that we are not unintentionally leaving wanted changes behind.</p>
<p>With these in mind, let&rsquo;s start writing the export logic.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">from</span> nypiapi <span style="color:#fff;font-weight:bold">import</span> versioning

<span style="color:#007f7f">#...</span>
<span style="color:#007f7f">#...</span>

<span style="color:#007f7f"># define the list of Process Groups</span>
process_groups = [ <span style="color:#0ff;font-weight:bold">&#34;RandomEvents&#34;</span> ]

<span style="color:#007f7f"># store exported flows</span>
exported_flows = {}
ExportedFlow = namedtuple(<span style="color:#0ff;font-weight:bold">&#34;ExportedFlow&#34;</span>, [<span style="color:#0ff;font-weight:bold">&#34;name&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;bucket_name&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;definition&#34;</span>])

<span style="color:#fff;font-weight:bold">for</span> pgn in process_groups:
    <span style="color:#007f7f"># make sure there&#39;s a Process Group on the Canvas</span>
    pg = nipyapi.canvas.get_process_group(pgn, greedy=<span style="color:#fff;font-weight:bold">False</span>)
    
    <span style="color:#fff;font-weight:bold">if</span> pg is <span style="color:#fff;font-weight:bold">None</span>:
        <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;process group </span><span style="color:#0ff;font-weight:bold">{</span>pgn<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> was not found in the Nifi Canvas&#34;</span>)
        exit(<span style="color:#ff0;font-weight:bold">1</span>)
  
    <span style="color:#007f7f"># make sure the process group is in the Registry</span>
    <span style="color:#fff;font-weight:bold">if</span> pg.component.version_control_information is <span style="color:#fff;font-weight:bold">None</span>:
        <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;process group </span><span style="color:#0ff;font-weight:bold">{</span>pgn<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> is not added to version control&#34;</span>)
        exit(<span style="color:#ff0;font-weight:bold">1</span>)
  
    <span style="color:#007f7f"># make sure there are no uncommitted changes on the Canvas</span>
    diff = nipyapi.nifi.apis.process_groups_api.ProcessGroupsApi().get_local_modifications(pg.id)
    diffn = <span style="color:#fff;font-weight:bold">len</span>(diff.component_differences)
    <span style="color:#fff;font-weight:bold">if</span> diffn &gt; <span style="color:#ff0;font-weight:bold">0</span>:
        <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;there are uncommitted changes in the process group </span><span style="color:#0ff;font-weight:bold">{</span>pgn<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
        exit(<span style="color:#ff0;font-weight:bold">1</span>)
  
    
    <span style="color:#007f7f"># since we are here, we found no issue with this Process Group</span>
    <span style="color:#007f7f"># let&#39;s export it</span>
  
    bucket_id = pg.component.version_control_information.bucket_id
    bucket_name = pg.component.version_control_information.bucket_name
    flow_id = pg.component.version_control_information.flow_id
  
    <span style="color:#007f7f"># export the latest version from the Registry</span>
    flow_json = versioning.export_flow_version(bucket_id, flow_id, version=<span style="color:#fff;font-weight:bold">None</span>)
    exported_flows[pgn] = ExportedFlow(pgn, bucket_name, flow_json)
</code></pre></div><p>There are few things to elaborate on in this part of the script.</p>
<ol>
<li>Notice that we are talking to <code>canvas.*</code> functions to understand the Canvas status. With the response we get from the Canvas, we can build the data we need for the subsequent API calls.</li>
<li>We then talk to <code>nifi.*</code> functions, that give us more information about the specific Process Group.</li>
<li>To get an export of the Process Group, we talk to the <code>versioning.*</code> functions in NipyAPI, which covers the Registry API.</li>
<li>We use a <code>namedtuple</code> to store the exported Process Group definition. In a later stage, we&rsquo;ll use the information in the Named Tuple to import the Process Group with correct information. This includes the Registry Bucket name. If you recall from the last post, we are going to use the same Bucket name in the other environments, to keep things simple.</li>
</ol>
<h2 id="importing-back-to-test-environment">Importing back to <code>test</code> environment</h2>
<h3 id="connecting-to-the-test-environment">Connecting to the <code>test</code> environment</h3>
<p>Before we perform any API calls, we need to switch the connection to the <code>test</code> environment.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#007f7f"># connect to Nifi</span>
nipyapi.utils.set_endpoint(<span style="color:#0ff;font-weight:bold">&#34;https://localhost:8444/nifi-api&#34;</span>)
<span style="color:#007f7f"># wait for connection to be set up</span>
connected = nipyapi.utils.wait_to_complete(
    test_function=nipyapi.utils.is_endpoint_up,
    endpoint_url=<span style="color:#0ff;font-weight:bold">&#34;https://localhost:8444/nifi&#34;</span>,
    nipyapi_delay=nipyapi.config.long_retry_delay,
    nipyapi_max_wait=nipyapi.config.short_max_wait
)

<span style="color:#007f7f"># connect to Nifi Registry</span>
nipyapi.utils.set_endpoint(<span style="color:#0ff;font-weight:bold">&#34;http://localhost:28080/nifi-registry-api&#34;</span>)
connected = nipyapi.utils.wait_to_complete(
    test_function=nipyapi.utils.is_endpoint_up,
    endpoint_url=<span style="color:#0ff;font-weight:bold">&#34;http://localhost:28080/nifi-registry&#34;</span>,
    nipyapi_delay=nipyapi.config.long_retry_delay,
    nipyapi_max_wait=nipyapi.config.short_max_wait
)
</code></pre></div><h3 id="registry-bucket">Registry Bucket</h3>
<p>As mentioned before, the Registry Bucket we are going to use across environments is the same. Therefore, in the <code>test</code> environment, we can perform a check to see if the Registry Bucket exists, and create if not.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#007f7f"># check if the Bucket already exists</span>
bucket = versioning.get_registry_bucket(bucket_name)

<span style="color:#fff;font-weight:bold">if</span> bucket is <span style="color:#fff;font-weight:bold">None</span>:
  bucket = versioning.create_registry_bucket(bucket_name)
</code></pre></div><h3 id="extra-checks">Extra checks</h3>
<p>We need to consider several scenarios in the case of the <code>test</code> environment.</p>
<ol>
<li>There could be a Process Group with the same name (or essentially the same Process Group) on the <code>test</code> Canvas, but not in the Registry Bucket. This could be because of various reasons, manual edits, user mistakes, or infrastructure failures.</li>
<li>The Process Group could be in the Registry Bucket, and in the Nifi Canvas, but there could be changes in the Canvas, that are not committed to version control. Ideally, a <code>test</code> or <code>production</code> environment should not have local changes, as any change should properly propagate along the path to production. However, a tester could do some tweaking to see which changes would solve a specific bug, or there could be a business requirement that forces local changes to be done on the environments other than <code>dev</code>. In any case, the APIs can&rsquo;t be used to import Process Groups with conflicting names, where there are uncommitted changes. These can be automatically <em>cleaned</em>, however, it&rsquo;s always advisable to keep this cleaning as a manual task, since vital information could also be lost during such a cleaning.</li>
</ol>
<p>If all these checks pass, we can proceed with importing the Process Groups on to Canvas.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">for</span> flow_name, exported_flow in exported_flows.items():
    bucket = versioning.get_registry_bucket(exported_flow.bucket_name)
    <span style="color:#fff;font-weight:bold">if</span> bucket is <span style="color:#fff;font-weight:bold">None</span>:
        bucket = versioning.create_registry_bucket(bucket_name)
        pg = nipyapi.canvas.get_process_group(flow_name, greedy=<span style="color:#fff;font-weight:bold">False</span>)
        <span style="color:#fff;font-weight:bold">if</span> pg is not <span style="color:#fff;font-weight:bold">None</span>:
            <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;process group exists on Canvas, but not in Registry: </span><span style="color:#0ff;font-weight:bold">{</span>flow_name<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
            exit(<span style="color:#ff0;font-weight:bold">1</span>)

    <span style="color:#fff;font-weight:bold">else</span>:
        bflow = versioning.get_flow_in_bucket(bucket.identifier, flow_name)
        pg = nipyapi.canvas.get_process_group(flow_name, greedy=<span style="color:#fff;font-weight:bold">False</span>)
        <span style="color:#fff;font-weight:bold">if</span> bflow is <span style="color:#fff;font-weight:bold">None</span> and pg is not <span style="color:#fff;font-weight:bold">None</span>:
            <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;process group exists on Canvas, but not in Registry: </span><span style="color:#0ff;font-weight:bold">{</span>flow_name<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
            exit(<span style="color:#ff0;font-weight:bold">1</span>)

        diff = nipyapi.nifi.apis.process_groups_api.ProcessGroupsApi().get_local_modifications(pg.id)
        diffn = <span style="color:#fff;font-weight:bold">len</span>(diff.component_differences)
        <span style="color:#fff;font-weight:bold">if</span> bflow is not <span style="color:#fff;font-weight:bold">None</span> and pg is not <span style="color:#fff;font-weight:bold">None</span> and diffn &gt; <span style="color:#ff0;font-weight:bold">0</span>:
            <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">F</span><span style="color:#0ff;font-weight:bold">&#34;there are uncommitted changes in the process group </span><span style="color:#0ff;font-weight:bold">{</span>pgn<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
            exit(<span style="color:#ff0;font-weight:bold">1</span>)
    
    
</code></pre></div><h3 id="parameter-contexts">Parameter Contexts</h3>
<p>Well, not exactly. There is an additional step we have to do before actually performing the API call to import Process Groups.</p>
<p>A Parameter Context in Nifi is basically a set of key value pairs that can be assigned to a Process Group (top level or inner ones). This is a concept that can be used to avoid hard coding environment specific values such as URLs, credentials, parallelization counts, and similar things. By using a Parameter Context, you are basically decoupling the business logic from the actual values.</p>
<p>For an example, if there&rsquo;s a WebSocket service that a certain Processor connects to, the URL to connect would be different in <code>dev</code> (and possibly <code>test</code>) environment than the one in the <code>production</code> environment. In this case, hard coding the URL in the Processor properties would make it hard to smoothly transition a change through the path to production. In this case, a Parameter Context can be defined (say <code>devparams</code>) in <code>dev</code> and the URL can be defined as a value with key <code>wssurl</code>. In the <code>ConnectWebSocket</code> Processor, this value can be referred to as <code>{#wssurl}</code> and Nifi will assign the value during runtime from the Parameter Context.</p>
<p>This however presents a problem for our script. When we used <code>versioning.export_flow_version()</code> function to export the Process Group, the associated Parameter Context was also exported. This can&rsquo;t be directly imported into the <code>test</code> environment, since Nifi does not allow importing an attached Parameter Context. In the versions that I deployed the more specific version of this script, Nifi would just put out an NPE without a proper explanation, however the cause is clear.</p>
<p>The solution is to sanitize the Flow definitions before we perform the import API call. We have to remove the references to the Parameter Contexts from the top level Process Group as well as any internal Process Groups (though our sample Process Group doesn&rsquo;t have any internal Process Groups or even a Parameter Context)</p>
<h3 id="create-or-update">Create or Update?</h3>
<p>After sanitization, we are finally ready to perform an import. After an import, we have to update Nifi Canvas so that the latest version imported into the Registry is reflected on the Canvas. However the way to do this differs if we are updating an existing flow. Therefore, we have to  first check if we need to perform an update API call instead of a create one, by checking if the Registry Bucket already has a Flow with the same name (a minor detail to note, if the Flow existed on the Canvas and not on the Registry, we&rsquo;d have errored out during the checks above).</p>
<p>With these considerations in mind, we can start writing the rest of the logic.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#fff;font-weight:bold">def</span> sanitize_pg(pg_def):
    <span style="color:#0ff;font-weight:bold">&#34;&#34;&#34;
</span><span style="color:#0ff;font-weight:bold">    sanitize the processGroup section from parameterContext references, does a
</span><span style="color:#0ff;font-weight:bold">      recursive cleanup of the processGroups if multiple levels are found.
</span><span style="color:#0ff;font-weight:bold">    &#34;&#34;&#34;</span>

    <span style="color:#fff;font-weight:bold">if</span> <span style="color:#0ff;font-weight:bold">&#34;parameterContextName&#34;</span> in pg_def:
        pg_def.pop(<span style="color:#0ff;font-weight:bold">&#34;parameterContextName&#34;</span>)

    <span style="color:#fff;font-weight:bold">if</span> <span style="color:#0ff;font-weight:bold">&#34;processGroups&#34;</span> not in pg_def or <span style="color:#fff;font-weight:bold">len</span>(pg_def[<span style="color:#0ff;font-weight:bold">&#34;processGroups&#34;</span>]) == <span style="color:#ff0;font-weight:bold">0</span>:
        <span style="color:#fff;font-weight:bold">return</span> pg_def

    <span style="color:#fff;font-weight:bold">for</span> pg in pg_def[<span style="color:#0ff;font-weight:bold">&#34;processGroups&#34;</span>]:
        sanitize_pg(pg)

<span style="color:#007f7f">#...</span>
<span style="color:#007f7f">#...</span>

<span style="color:#007f7f"># get the registry client for the test environment, we need this to import</span>
<span style="color:#007f7f"># process groups</span>
reg_clients = versioning.list_registry_clients()
test_reg_client = <span style="color:#fff;font-weight:bold">None</span>

<span style="color:#007f7f"># just getting the first registry client we find, assuming we only have one</span>
<span style="color:#fff;font-weight:bold">for</span> reg_client in reg_clients.registries:
    test_reg_client = reg_client.component
    <span style="color:#fff;font-weight:bold">break</span>

<span style="color:#007f7f"># read the Canvas root element ID to attach Process Groups</span>
root_pg = nipyapi.canvas.get_root_pg_id()

<span style="color:#fff;font-weight:bold">for</span> flow_name, exported_flow in exported_flows.items():
    flow = json.loads(exported_flow.definition)
  
    <span style="color:#007f7f"># get the bucket details</span>
    bucket = versioning.get_registry_bucket(exported_flow.bucket_name)
  
    <span style="color:#007f7f"># remove from top level Process Group</span>
    <span style="color:#fff;font-weight:bold">if</span> <span style="color:#0ff;font-weight:bold">&#34;parameterContexts&#34;</span> in flow:
        param_ctx = flow[<span style="color:#0ff;font-weight:bold">&#34;parameterContexts&#34;</span>]
        flow[<span style="color:#0ff;font-weight:bold">&#34;parameterContexts&#34;</span>] = {}
        <span style="color:#fff;font-weight:bold">if</span> <span style="color:#0ff;font-weight:bold">&#34;parameterContextName&#34;</span> in flow[<span style="color:#0ff;font-weight:bold">&#34;flowContents&#34;</span>]:
            flow[<span style="color:#0ff;font-weight:bold">&#34;flowContents&#34;</span>].pop(<span style="color:#0ff;font-weight:bold">&#34;parameterContextName&#34;</span>)
    
    <span style="color:#007f7f"># additionally, sanitize inner Process Groups</span>
    <span style="color:#fff;font-weight:bold">for</span> pg in flow[<span style="color:#0ff;font-weight:bold">&#34;flowContents&#34;</span>][<span style="color:#0ff;font-weight:bold">&#34;processGroups&#34;</span>]:
          sanitize_pg(pg)
    
    sanitized_flow_def = json.dumps(flow)
  
    <span style="color:#007f7f"># check if the process group exists in the bucket </span>
    existing_flow = versioning.get_flow_in_bucket(bucket.identifier, flow_name)
    <span style="color:#fff;font-weight:bold">if</span> existing flow is <span style="color:#fff;font-weight:bold">None</span>:
        <span style="color:#007f7f"># import anew into the Registry</span>
        vflow = versioning.import_flow_version(
                                bucket.identifier,
                                encoded_flow=sanitized_flow_def,
                                flow_name=flow_name)
        time.sleep(<span style="color:#ff0;font-weight:bold">5</span>)
    
        <span style="color:#007f7f"># deploy anew into the Canvas</span>
        versioning.deploy_flow_version(
                parent_id=root_pg,
                location=(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>),
                bucket_id=bucket.identifier,
                flow_id=vflow.flow.identifier,
                reg_client_id=test_reg_client.id,
                )
    <span style="color:#fff;font-weight:bold">else</span>:
        <span style="color:#007f7f"># update Flow in Registry in place</span>
        vflow = versioning.import_flow_version(
                bucket_id=bucket.identifier,
                encoded_flow=sanitized_flow_def,
                flow_id=existing_flow.identifier)
        time.sleep(<span style="color:#ff0;font-weight:bold">5</span>)
    
        <span style="color:#007f7f"># check if the Canvas already has the Process Group</span>
        pg = nipyapi.canvas.get_process_group(flow_name, greedy=<span style="color:#fff;font-weight:bold">False</span>)
        <span style="color:#fff;font-weight:bold">if</span> pg is <span style="color:#fff;font-weight:bold">None</span>:
            <span style="color:#007f7f"># deploy anew into the Canvas</span>
            versioning.deploy_flow_version(
                    parent_id=root_pg,
                    location=(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>),
                    bucket_id=bucket.identifier,
                    flow_id=vflow.flow.identifier,
                    reg_client_id=test_reg_client.id,
                    )
        <span style="color:#fff;font-weight:bold">else</span>:
            <span style="color:#007f7f"># update Canvas in place</span>
            versioning.update_flow_ver(process_group=pg)
</code></pre></div><p>Things to note in this part of the script are,</p>
<ol>
<li><code>sanitize_pg()</code> function, which is a recursive function to clean any Process Group found at any level to strip Parameter Context information.</li>
<li>Reading the Registry Client information, which is later used as a reference for the Process Group import function</li>
<li>Use of the <code>versioning.import_flow_version()</code> function when creating vs updating. Creation of a Flow in the Registry does not require a Flow identifier, since there is none to refer to in the Registry. In contrast, updating requires you to specify the Flow identifier.</li>
<li>The function to deploy a Flow from the Registry to the Canvas is in the <code>versioning</code> package. This requires the root Process Group to refer to, since a Process Group can also attached to another Process Group. In our case, we are going to import the Process Group to the top level Nifi Canvas.</li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<h2 id="end-results">End results</h2>
<p>The final result of this script being executed can be seen in the following screenshot. <code>dev</code> is on the left side, and <code>test</code> is on the right.</p>
<p><img src="/blog/img/2021-07-18_nifi_cicd_final_result.png" alt="Nifi CICD script execution"></p>
<p>If I wanted to propagate a change, I can do so by committing the changes again to the Registry in <code>dev</code> and running this script again.</p>
<p><img src="/blog/img/2021-07-18_nifi_cicd_incr_changes.png" alt="Committing changes"></p>
<p>By looking at the versions in the <code>test</code> version I can verify the version I&rsquo;m at by referring to the commit message (another reason why you should use meaningful commit messages).</p>
<p><img src="/blog/img/2021-07-18_nifi_cicd_incr_changes_02.png" alt="Changing versions"></p>
<p><img src="/blog/img/2021-07-18_nifi_cicd_incr_changes_03.png" alt="Viewing versions"></p>
<p>You can also check the version history from the Registry UI itself.</p>
<p><img src="/blog/img/2021-07-18_nifi_cicd_incr_changes_04.png" alt="Viewing versions"></p>
<h2 id="quirks">Quirks?</h2>
<p>Yeah, a few.</p>
<h3 id="with-the-design">With the design</h3>
<ol>
<li>As you have already noticed, this design focuses on separating different environments entirely. However, the Registry component can easily be shared between environments. This can be done by either keeping the Bucket names different (ex: <code>realtimestats-dev</code> and <code>realtimestats-test</code>) and perform the same import/export API calls between the Buckets, or just using one Bucket and using it as central place to pull from, for the non-dev environments. In fact, it seems from the documentation, that this is the user story Nifi project had in mind in the first place. However, depending on the set of requirements, these environments would have to be separated. This could be because of security concerns, compliance issues, architecture restrictions, or a strong desire to keep things separated. In any case, many of the above API calls do not change based on the design.</li>
<li>This approach does not allow changes to be done on the Flow definitions after the <code>dev</code> environment. Though this is the ideal way of doing things, business requirements, or time constraints could force local changes to be made on the (ex:) <code>test</code> environment. In these cases, it&rsquo;s better to commit the changes and perform the migration tasks on those committed versions.</li>
<li>Nifi Registry&rsquo;s user management features have not been taken into account. This is out of scope of these two posts.</li>
</ol>
<h3 id="with-the-script">With the script</h3>
<ol>
<li>You may have noticed that if you run the above script again and again, the same version would get <em>replayed</em> on top of the existing version on the target environment. This is something we can&rsquo;t avoid at the API level. Serialization that happens upon <code>versioning.export_flow_version()</code> API call inserts UUIDs and timestamps that are unique to each operation. Therefore, there is no way (at the moment this post is being written), to compare an existing version and avoid an import if the contents are the same. We could hypothetically compare commit messages, however given how careless a normal developer is with commit messages, it&rsquo;s entirely possible different commits would have the same commit messages. Therefore, this would have to be tolerated as something that can&rsquo;t be overcome at the moment.</li>
<li>Commit replay itself is another issue. From the above screenshot of the <code>test</code> environment version history, you can see that the timestamp of the commit is not entirely the timestamp the change was originally made at. The Registry level operation when importing a specific version is more like a git patch application than a <code>git pull -r</code>. You lose a certain set of metadata this way.</li>
<li>There are more edge cases where this script could easily break. There could be different Process Groups with similar names, and because of the way the <code>get_flow_in_bucket()</code> API method operates, all of the Process Groups could return as part of the API call. Some parts of the SDK are still a bit brittle, so more exception handling may be needed.</li>
</ol>
<p>This is just one way of performing this task. The decoupling between Nifi and the Registry allows different designs to be implemented based on organizational requirements.</p>
<p>The code and the config files referred to in these two posts are available at <a href="https://github.com/chamilad/nifi_cicd_poc"><code>chamilad/nifi_cicd_poc</code></a> repository. Please open an issue if you want to clarify anything.</p>

        </div>
        <div class="prev-next row">
	<div class="prev col-sm">
	
	<a href="https://chamila.dev/blog/2021-07-17_ci-cd-for-apache-nifi-01-intro-and-setup/">&lt; CI/CD for Apache Nifi 01 - Introduction and Set up</a>
		
	</div>        
	<div class="next col-sm">
	
	<a href="https://chamila.dev/blog/2021-11-12_automating-snowflake/">Automating Snowflake &gt;</a>
		
	</div>
</div>


        

        

<div class="releated-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/blog/2021-07-17_ci-cd-for-apache-nifi-01-intro-and-setup/">CI/CD for Apache Nifi 01 - Introduction and Set up</a></li>
    
  </ul>
</div>


        
        
        
        
        

        <div class="site-footer">
  <div class="sm-icons">
  <a href="https://chamila.dev//blog/index.xml" target="_blank" title="rss">
    <i class="fas fa-rss sm-icon"></i>
  </a>
  <a href="https://github.com/chamilad" target="_blank" title="github">
    <i class="fab fa-github sm-icon"></i>
  </a>
  <a href="https://fosstodon.org/@chamilad" target="_blank" title="fosstodon" rel="me">
    <i class="fab fa-mastodon sm-icon"></i>
  </a>
</div>

  <span> All photos published on this site are copyrighted. </span>
  <div class="site-footer-item">
    Modified
    <a href="https://github.com/joway/hugo-theme-yinyang" target="_blank">YinYang</a>
    theme
  </div>
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>
<script src="/js/theme.js"></script>


<script>
  hljs.initHighlightingOnLoad();

  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>
