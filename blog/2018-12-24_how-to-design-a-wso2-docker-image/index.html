<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.105.0">

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://chamila.dev/blog/2018-12-24_how-to-design-a-wso2-docker-image/" />
  <link rel="canonical" href="https://chamila.dev/blog/2018-12-24_how-to-design-a-wso2-docker-image/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/chamila.dev\/"
      },
      "articleSection" : "blog",
      "name" : "How to Design a WSO2 Docker Image",
      "headline" : "How to Design a WSO2 Docker Image",
      "description" : "What should be your concerns for WSO2 on Docker? Deploying WSO2 products on Containerized platforms is a well-tested well-resourced activity. There are various resources available to deploy WSO2 products on Docker, Kubernetes, CloudFoundry, AWS ECS, and Apache Mesos, both officially and unofficially. However, designing a Docker image so that optimal non-functional traits like performance, operational efficiency, and security is a separate topic in itself.\nDocker, being both a DSL and a utility tool for Container image packaging, can be written in several different ways keeping various operational goals in mind.",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2018",
      "datePublished": "2018-12-24 16:49:16.523 \u002b0000 UTC",
      "dateModified" : "2018-12-24 16:49:16.523 \u002b0000 UTC",
      "url" : "https:\/\/chamila.dev\/blog\/2018-12-24_how-to-design-a-wso2-docker-image\/",
      "keywords" : [ "Docker","Wso2","Containers","K8s","Api Management", ]
  }
</script>
<title>How to Design a WSO2 Docker Image - chamila.dev</title>
  <meta property="og:title" content="How to Design a WSO2 Docker Image - chamila.dev" />
  <meta property="og:type" content="article" />
  <meta name="description" content="What should be your concerns for WSO2 on Docker? Deploying WSO2 products on Containerized platforms is a well-tested well-resourced activity. There are various resources available to deploy WSO2 products on Docker, Kubernetes, CloudFoundry, AWS ECS, and Apache Mesos, both officially and unofficially. However, designing a Docker image so that optimal non-functional traits like performance, operational efficiency, and security is a separate topic in itself.
Docker, being both a DSL and a utility tool for Container image packaging, can be written in several different ways keeping various operational goals in mind." />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link rel="stylesheet" href="/css/light.css">
  <link rel="stylesheet" href="/css/dark.css">
  <link href="/blog/index.xml" rel="alternate" type="application/rss+xml" title="chamila.dev">

  <link href="/fa/css/all.css" rel="stylesheet">

  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  

  <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
</head>


<body class="theme-light">
  <article class="post " id="article">
    <div class="row">
      <div class="container col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div id="floating-menu-wrapper">
  <div id="floating-menu">
    <button id="switch-to-dark" title="dark theme">
      <i class="fas fa-moon"></i>
    </button>
    <button id="switch-to-light" title="light theme" class="current-theme">
      <i class="fas fa-sun"></i>
    </button>
  </div>
</div>

        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <span class="breadcrumbs">
      <a href="https://chamila.dev/">chamila.dev</a> >
      <a href="https://chamila.dev//blog"> journal </a> >
    </span>
    <div class="sm-icons">
  <a href="https://chamila.dev//blog/index.xml" target="_blank" title="rss">
    <i class="fas fa-rss sm-icon"></i>
  </a>
  <a href="https://github.com/chamilad" target="_blank" title="github">
    <i class="fab fa-github sm-icon"></i>
  </a>
  <a href="https://fosstodon.org/@chamilad" target="_blank" title="fosstodon">
    <i class="fab fa-mastodon sm-icon"></i>
  </a>
</div>

  </div>
</header>
<div class="row end-xs">
   
</div>


        </div>
        <header class="post-header">
          <h1 class="post-title">How to Design a WSO2 Docker Image</h1>
          
          <div class="row post-desc">
            <div class="pub-date col-xs-6">
              
              <time class="post-date" datetime=" 2018-12-24 16:49:16 UTC">
                24 Dec 2018
              </time>
              
            </div>
            <div class="reading-time col-xs-6" title="approximate read time">
              ~20 minutes
            </div>
            
            
            
          </div>
          
          <div class="toc">
            
            <h4>Table of Contents:</h4>
            <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#the-range-ofoptions">The Range of Options</a></li>
        <li><a href="#generic-approach">Generic Approach</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
            
          </div>
        </header>
        <div class="post-content markdown-body">
          <h4 id="what-should-be-your-concerns-for-wso2-ondocker">What should be your concerns for WSO2 on Docker?</h4>
<p><img src="/blog/img/2018-12-24_how-to-design-a-wso2-docker-image_0.jpeg#layoutTextWidth" alt=""></p>
<p><a href="/thinking-of-moving-your-wso2-deployment-on-to-kubernetes-4e9a77b3377d">Deploying WSO2 products on Containerized platforms</a> is a well-tested well-resourced activity. There are various resources available to deploy WSO2 products on <a href="https://github.com/wso2/docker-apim">Docker</a>, <a href="https://github.com/wso2/kubernetes-apim/">Kubernetes</a>, <a href="https://github.com/wso2/pivotal-cf-apim">CloudFoundry</a>, AWS ECS, and <a href="https://github.com/wso2/dcos-apim">Apache Mesos</a>, both officially and unofficially. However, designing a Docker image so that optimal non-functional traits like performance, operational efficiency, and security is a separate topic in itself.</p>
<!-- raw HTML omitted -->
<p>Docker, being both a DSL and a utility tool for Container image packaging, can be written in several different ways keeping various operational goals in mind. These approaches vary from an all files and configs pre-baked end to another end where almost everything, except a tiny helper layer, being mounted at Container run-time. However, not all these approaches are suitable for a WSO2 deployment, and figuring out these details can be a daunting task, especially at an earlier phase of the deployment. Therefore, it’s important to have a set of common <strong>guidelines</strong>that can help determine which approach to take in each case. I emphasize the word <strong>guidelines</strong> because these are only them, not hard rules or must-do’s in every deployment. There is freedom for the user to stray away, as long as the compromises made in doing so are understood.</p>
<h3 id="the-range-ofoptions">The Range of Options</h3>
<p>The strategies for designing a particular Docker image can be a per-scenario basis one. In one end, all the files needed are packed into the image itself at build time, and Container creation does not have any additional tasks to perform other than server specific runtime configuration. In this case the Dockerfile and the builder scripts will be heavy with artifact copying, file configuration, and handling various runtime differences at the build time itself. Most of the times, even Configuration Automation tools like Puppet or Ansible may also be involved. For a WSO2 deployment, this would make use of <a href="https://github.com/wso2/puppet-apim/">Puppet</a> and <a href="https://github.com/wso2/ansible-apim/">Ansible</a> modules for WSO2 to pre-configure every minute detail of the product <strong>at the time of the image build</strong>.</p>
<p>The downside of this approach is that since products, specially WSO2 products, can contain a rather long list of configuration options, the iterations to get a minor configuration detail to a running deployment could be more than what is preferable in terms of operational efficiency. Docker image builds could be time consuming, especially if the <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache">build cache is not being effectively utilized</a>. Furthermore, if the particular image is large in size it occupies on the disk (collectively), then iterative images could take considerable time to be downloaded to running compute nodes.</p>
<p>On the other end is the approach where only the bare necessary files are packed into the image at build time. This in turn will require the Container creation process to either create or mount necessary file based artifacts based on runtime parameters. In this case, the startup scripts that get executed as part of the <code>ENTRYPOINT</code> instruction could be heavy and complex since it has to leverage various inputs and possibilities for those inputs to result in the desired function. This can soon become too complex to debug or develop upon since almost always what carries the weight here is a Bash or a PowerShell script. However, this approach is the most Ops-personnel friendly (note that I only emphasized personnel and left out Ops) one since no build jobs or image downloads have to be done in order to propagate a new change to a running deployment. Configuration Automation tools may or may not be involved in this layer. However, since they tend to be time consuming and heavy in operation, they do not go well with the Containerization principle to have as small startup times as possible. In addition to having a complex startup flow, this approach can also result in file lock and data conflicts when the same set of files are shared between different instances of the product. In WSO2 deployments, there potential points of conflict are configuration files, instance local databases, deployable artifacts, indexes, and logs that need to be separate between instances. If everything is mounted and shared between instances these will eventually result in conflicts and corrupt a deployment beyond all recognition.</p>
<p>It’s obvious that a specific user story will require the selection of an option somewhere between these two ends of the spectrum. Following are a set of principles that can help deciding where to place your approach between them.</p>
<h4 id="parent-image">Parent Image</h4>
<p><a href="https://docs.wso2.com/display/compatibility/Tested+Operating+Systems+and+JDKs">WSO2 products are supported through various Operating Systems</a>, including Windows, several Linux flavors, and MacOS. Out of these, Linux flavors such as Ubuntu, Debian, and RedHat family OSs are supported readily. Though other Linux flavors are not heavily tested upon, as long as the core dependencies of Java and Bash are supported, majority of the use cases should be running without any problems.</p>
<p>Selecting a proper parent image is a multi-faceted task. Since WSO2 products are based on Java, they cannot be run without an initial file system and settings . In other words just including the WSO2 product inside a pure <code>FROM scratch </code>Docker image will not work. Java requires various OS level utils and in turn they require a considerably laid out initial file system. Therefore, WSO2 parent images <strong>should</strong>be Operating System images.</p>
<p>When it comes to selecting a parent operating system image for the WSO2 Docker image, consider the following criteria.</p>
<ul>
<li>Do you have<strong>specific tools that are supported only on a certain distribution</strong>? e.g. monitoring and log collection agents, continuous auditing tools, configuration automation agents/tools</li>
<li>Do you have<strong>security concerns when it comes to the OS that favor a specific OS and a version</strong> with previous experience? Some OS images have more tools and utils that accompany the main Containerized process. Those additional processes potentially expose an attack surface through unknown (and sometimes known but not properly secured) vulnerabilities.</li>
<li>Do you have <strong>organizational policies and restrictions that dictate use of only a specific OS and a version</strong> for any work to be done inside the organization? This can be part of a security audit based recommendation or more business oriented with enterprise support and partnerships involved.</li>
<li><strong>What is your most experienced expertise on?</strong> Is it Debian, RedHat, or Arch (or something else) based? Do your existing shell scripts support a flavor-agnostic deployment or are they dependent on a specific Bash version and/or a Linux flavor? Switching to a whole new OS image may put unnecessary pressure on your Ops (and Dev) cycles.</li>
<li>Which OS images offer the <strong>lowest sizes possible within the business requirements</strong>? Would a minimal Alpine OS image cover all the scenarios in question with the same level of performance, security, and ops efficiency that a more full-fledged distribution like Debian or RedHat does?</li>
</ul>
<p><a href="https://github.com/wso2/docker-apim/tree/master/dockerfiles">WSO2 offers Dockerfiles and init scripts</a> for Ubuntu, CentOS, and Alpine as Open Source artifacts. Furthermore, Docker images (built using the above Dockerfiles) are available on the <a href="http://docker.wso2.com/">WSO2 Docker Registry</a> to be pulled directly.</p>
<p><img src="/blog/img/2018-12-24_how-to-design-a-wso2-docker-image_2.png#layoutTextWidth" alt=""></p>
<h4 id="dockerfile-composition">Dockerfile Composition</h4>
<p>When it comes to the Dockerfile which is the descriptor for the consequent image being built, there are various optimizations and best practices to follow for a cleaner, more debuggable, and more build-time efficient processes.</p>
<p><strong>Copying the WSO2 product</strong>— WSO2 products are distributed as compressed zip files, <a href="https://wso2.com/api-management/install/">downloadable from the WSO2 site</a> or buildable through <a href="https://wso2.com/updates/wum">WSO2 Update Manager</a> with a <a href="https://wso2.com/subscription/">Support Subscription</a>. Copying this pack to the Docker image would most probably be done as a conventional <code>COPY</code> instruction and then a subsequent <code>RUN</code> instruction would unzip the pack to a desired location.</p>
<p>However, this approach is a sub-optimal one when it comes to both the build cache and the image size. <code>COPY</code> instruction adds a layer close to the size of the zip file to the Docker image. The subsequent <code>RUN</code> instruction also adds another layer with similar or more size since it will be doing COW<a href="https://docs.docker.com/storage/storagedriver/#container-and-layers"> (Copy-On-Write) operations</a> on contents of a previous layer. Furthermore, if you’re not careful, the copied zip file could also be packed into the final image along with the extracted product. For a WSO2 API Manager Docker image, this can add more than 1GB of size to the final Docker image.</p>
<p>What official WSO2 Dockerfiles have followed to overcome this limitation is a simple one. The WSO2 pack is extracted before it’s being copied to the Docker image, in the Dockerfile context location. <a href="https://github.com/wso2/docker-apim/tree/master/dockerfiles/ubuntu/apim">The </a><a href="https://github.com/wso2/docker-apim/tree/master/dockerfiles/ubuntu/apim"><code>COPY</code></a><a href="https://github.com/wso2/docker-apim/tree/master/dockerfiles/ubuntu/apim"> instruction copies an extracted folder to the Docker image</a>. This approach removes the need to add a specific <code>RUN</code> instruction to extract and delete the zip file. Furthermore, any changes that have to be done to a product pack (e.g. change the theme configurations for WSO2 API Manager Publisher UI) can be done outside of the Docker image build process, saving both the build time and the image size.</p>
<p>To add another small detail, when copying and configuring the WSO2 pack inside the Docker image, keep a note to do so in the same locations as a VM based deployment would do. For an example, if on your typical VM based WSO2 deployment, the product is running from <code>/opt/wso2am-2.6.0</code> with <code>/opt/wso2am</code> acting as an easy access symbolic link, do the same in the Docker image as well. This will make the life much more easier for the Ops work that involves setting up tasks like monitoring and logging, and post-incident troubleshooting.</p>
<blockquote>
<p>WSO2 products are also available as OS specific installers such as .deb or .rpm packages. In this case, they are installed to a specific location unique to the OS (e.g. <code>/usr/lib/WSO2</code> ).</p>
</blockquote>
<p><strong>Presence of the JDK</strong>— As stated earlier, WSO2 products need a JDK implementation to be run. The supported JDKs can be found at the <a href="https://docs.wso2.com/display/compatibility/Tested+Operating+Systems+and+JDKs">documentation on compatibility</a>. For Docker images, this can be a JDK copied from outside, or a JDK already present in the parent image.</p>
<p>Similar to the above description involving the WSO2 product, copying, extracting, and configuring the JDK could add undesirable size to the image. A similar solution could also be carried out for the JDK, however editing the JDK should be done with care <a href="https://blog.takipi.com/running-java-on-docker-youre-breaking-the-law/">not to violate the Oracle JDK</a>.</p>
<p>A better approach would be to use <a href="https://hub.docker.com/_/openjdk/">an OpenJDK image as the parent image</a>. There are various Linux flavors supported in the list of tags available and it’s a simple <code>FROM</code> instruction as opposed to the combination of extract and <code>COPY</code> or even worse, a combination of <code>COPY</code>, <code>RUN</code>, and <code>ENV</code>.</p>
<p><strong>Labels</strong>— Docker introduced image Labels recently as a way to embed metadata into the image. <a href="/lets-make-your-docker-image-better-than-90-of-existing-ones-8b1e5de950d">Leveraging this feature generously</a> is a good precaution to take in order to increase both the observability and the accountability of a system, even if those are non-goals at the start of a project.</p>
<p><strong>Build Args</strong>— Docker <a href="https://docs.docker.com/v17.09/engine/reference/builder/#arg">build time arguments</a> allow values to be passed to the Docker image that can change the build process based on those values. For an example, <a href="https://github.com/wso2/docker-apim/blob/master/dockerfiles/ubuntu/apim/Dockerfile#L36">a single Dockerfile can build images for multiple WSO2 API Manager versions with a </a><a href="https://github.com/wso2/docker-apim/blob/master/dockerfiles/ubuntu/apim/Dockerfile#L36"><code>--build-arg</code></a><a href="https://github.com/wso2/docker-apim/blob/master/dockerfiles/ubuntu/apim/Dockerfile#L36"> specifying the version number at build time</a>. This approach can save a lot of repetition and maintenance overhead for Dockerfiles that otherwise would have to be achieved through “clever” workarounds.</p>
<p><code>RUN</code><strong>Instructions</strong>— <code>RUN</code> instructions and the ordering of them contribute directly to the size of the final image and the readability of the Dockerfile. For an example consider the following simple Dockerfile.</p>
<!-- raw HTML omitted -->
<p>What this does is to copy the <code>wso2am-2.6.0</code> folder to <code>/opt/</code> (as we discussed above), create a Linux user and a group named <code>wso2carbon:wso2</code>, change ownership of the WSO2 product to the created user and group, and then change their Linux permissions to <code>0755</code> (user-<code>rwx</code>, group-<code>r-x</code>, world-<code>r-x</code>). The same can be written as the following where the <code>WORKDIR</code> instruction is moved after the <code>chmod</code> operation and merging the <code>RUN</code> instructions together.</p>
<!-- raw HTML omitted -->
<p>Now let’s compare the resulting images, <code>wso2am:2.6.0.v1</code> and <code>wso2am:2.6.0.v2</code>.</p>
<p><img src="/blog/img/2018-12-24_how-to-design-a-wso2-docker-image_5.png#layoutTextWidth" alt=""></p>
<p>As evident, the change in the ordering of the <code>RUN</code> instruction has resulted in an image size difference of <strong>550MB</strong>. That is a huge difference in size for a simple <code>chmod</code> operation. Looking at the sizes of the separate layers, we can understand how this has come about.</p>
<!-- raw HTML omitted -->
<p>This is to do with the additional <a href="https://docs.docker.com/storage/storagedriver/#container-and-layers">COW (Copy-On-Write) operations</a> that <code>chmod</code> does on a <strong>separate</strong> layer. When we merge the sensible <code>RUN</code> instructions together, there is no need to do Copy-on-Write as the operations are happening in the <strong>same</strong> layer.</p>
<h4 id="least-privileged-users">Least Privileged Users</h4>
<p>Docker Containers are run using <code>root</code> user unless otherwise specified by a <code>USER</code> Dockerfile instruction. Although this is a root user on an isolated namespaced process (with other Kernel level jails in place), there have been proof of concepts that make use of vulnerabilities of the Kernel, applications, and tools involved to break out to the underlying host layer. If this exploit happens from within a Container running as <code>root</code>, then the Containerized exploited process will also have root privileges in the host.</p>
<p>Therefore, it’s advised as a best practice not to run Docker Containers with <code>root</code> user as the process owner. Like demonstrated above, creating a specific user (and group) with only access to the WSO2 product location and process is a suitable precaution.</p>
<!-- raw HTML omitted -->
<p>Furthermore, when using the <code>COPY</code> instruction, the flag <code>--chown</code> can be used to set the ownership of the target location without having to add a separate <code>RUN</code> instruction to do so.</p>
<blockquote>
<p>**EDIT:**It should be noted that the important detail to implement is the specific UID and the GID for the non-privileged user. A specific UID and a GID makes sure that no clashes or unanticipated side effects occurring between users and groups on the host and the Containers. A known value also makes sure that privileges can be restricted on the host machine for that specific UID.</p>
</blockquote>
<h4 id="run-time-details">Run-time Details</h4>
<p>It’s most likely that there will be a thin bootstrap layer that acts as the main process of the Container. It will do some configurations, file manipulations, set environment variables, and finally will start the WSO2 Carbon server. It would be ideal to keep the list of bootstrap operations to a minimum to adhere to an agreed maximum Container startup time.</p>
<p>The script should ideally pass any runtime arguments set at the Container runtime to the <code>wso2carbon.sh</code> process that it would invoke at the end. This enables scenarios like having to open up a remote debug port to a specific Container, without having to modify the Docker image itself.</p>
<p>It’s important to understand the minor differences and the implementation nuances when it comes to the use of <code>ENTRYPOINT</code> and <code>CMD</code> instructions in the WSO2 Docker image. Mainly,</p>
<ol>
<li>Use <code>ENTRYPOINT</code> instruction to invoke the bootstrap script. The <code>CMD</code> instruction can be overridden and should be used for other purposes.</li>
<li>Use <a href="https://docs.docker.com/engine/reference/builder/#exec-form-entrypoint-example">exec forms when specifying the </a><a href="https://docs.docker.com/engine/reference/builder/#exec-form-entrypoint-example"><code>ENTRYPOINT</code></a><a href="https://docs.docker.com/engine/reference/builder/#exec-form-entrypoint-example"> instruction</a>. This will enable the use of later added <code>CMD</code> values and overridden arguments.</li>
<li>The <code>CMD</code> instruction could be used in child images to enable a workflow where the <code>ENTRYPOINT</code> in a parent image specifies the bootstrap script and the <code>CMD</code> instructions in different child images can invoke the different functionalities in the WSO2 Carbon server, such as the OSGi console, remote debug ports, and setting various system properties. Based on this, there could be different (child) images to troubleshoot a scenario, enable or disable TLS1.2, or even going as far as to invoke different profiles of the same WSO2 server.</li>
</ol>
<h4 id="init-process">Init Process</h4>
<p>One minor detail that is almost always kept out of discussions is the the process to be used as the parent process for Containers. <a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">Because of how Linux processes are supposed to manage child processes, Bash scripts do not make good init processes</a>. Therefore, it’s always a good practice to invoke the bootstrap Bash scripts through a simple, light-weight, Container-friendly init system such as <a href="https://github.com/Yelp/dumb-init">dumb_init</a> or <a href="https://github.com/phusion/baseimage-docker/blob/rel-0.9.16/image/bin/my_init">my_init</a>. These will reap the child images gracefully and handle UNIX signals as they are supposed to be by a parent process.</p>
<h4 id="dynamically-loaded-configuration-deployable-artifacts-andlogs">Dynamically Loaded Configuration, Deployable Artifacts, and Logs</h4>
<p>Configurations for WSO2 servers are mostly stored in XML files inside <code>&lt;CARBON_HOME&gt;/repository/conf/</code> folder. Changes done to almost all of these files are not dynamically loaded. To make the changes take effect the JVM has to be restarted. In Container speak, this effectively means the death of the Container. Therefore, there is no possible user story where changes done to dynamically mounted configuration files can affect a running WSO2 server.</p>
<p>One useful exception to this is the logging configuration. Though the changes done to <code>&lt;CARBON_HOME&gt;/repository/conf/log4j.properties</code> file are also not dynamically loaded, <a href="https://docs.wso2.com/display/ADMIN44x/Configuring+Log4j+Properties">WSO2 Carbon UI offers a configuration page that can be used to change the logging levels of all the loaded classes dynamically</a>. Changing the values in this UI will take effect immediately, however those changes are in effect only until the JVM is shutdown.</p>
<p>On the contrary to the configuration files, the file based artifacts are dynamically loaded. These file based artifacts reside inside <code>&lt;CARBON_HOME&gt;/repository/deployment/server</code> in a single tenant deployment. Artifacts like Synapse configurations (proxy configurations, APIs, and other sequence definitions), event publishers and receivers, Jaggery applications, and web applications can be deleted and restored to take effect without having to restart the WSO2 server. Therefore, dynamically mounting these make the most sense rather than prebaking them into the image. Taking a prebake approach could force unnecessary build cycles to propagate minor deployment changes to live environments.</p>
<p>Another deployment aspect to be aware about are the instance local storages. These include the H2 database that contains the Local Registry, and the Solr indexes if present. Although these are specific to a single WSO2 server instance, the changes done in them during the runtime should be persisted across instance restarts. For Containers this means having to offload these artifacts to Container instance specific mounts that do not get deleted after the Container instance is stopped. Although losing these storages are not catastrophic to a deployment, rebuilding them (e.g. Solr indexes) could take time and result in unanticipated side effects. For an example, a missing Solr index of a WSO2 API Manager Publisher instance could result in a brief empty list of APIs in the UI.</p>
<p>Log files are generated by each instance separately. However, keeping these only in the ephemeral file system provided to the Container will create a troubleshooting nightmare where logs of the killed Containers are missing in action after the Container file systems are deleted. Ideally, logs should be pushed off to a centralized log aggregator (and analyzer). How to do this for systems like <a href="/publishing-wso2-logs-to-splunk-from-a-containerized-deployment-a19ab743c84e">Splunk</a> and <a href="/monitoring-wso2-logs-with-elasticsearch-logstash-and-kibana-or-grafana-1f880f6ed056">ELK</a> are <a href="/thinking-of-moving-your-wso2-deployment-on-to-kubernetes-4e9a77b3377d">well-tested well-documented scenarios</a>. If such systems are not in place yet, logs can simply be mounted out to the host instance, that would probably sync them to a remote storage for archival.</p>
<h4 id="config-automation">Config Automation</h4>
<p>Because of the flexibility of WSO2 servers to adapt to most use cases, the servers themselves contain a large list of configuration options. At the beginning of a deployment, these changes would most probably be small, including only the hostname, port offsets, and may be a few datasources. It’s tempting to do these changes only with the initial bootstrap scripts that involve tools like <code>grep</code> and <code>sed</code>. However the use of these tools quickly become overwhelming when the larger scope of configurations come into play.</p>
<p>Configuration Automation is almost always recommended as a tool for deployment management for WSO2. Apart from managing the large list of configurations and artifacts that WSO2 servers manage, a Configuration Automation system will also streamline the propagation of new fixes shipped by <a href="https://wso2.com/updates/wum">WSO2 through the WSO2 Update Manager (WUM</a>).</p>
<p>When it comes to Containerization, a Configuration Automation tool will be helpful in the image building process to prebake the required details in to the file system image. These details should include the server configuration, the binaries, the theme files, customizations, and the patches required. It can also include deployable artifacts, taking the approach the fully prebake end, however they should be in sync with the runtime deployable artifacts location for the new images to contain the latest artifacts (It should be noted that the better approach that would suit most use cases would be to use an approach where all except the deployable artifacts are prebaked into the image and have the deployable artifacts be mounted to the Containers during runtime). This process can be plugged into a build automation tool like Jenkins where image building based on changes done to the configuration can be automated (Continuous Integration) and new changes can be propagated to the live system through a combination of the Container Orchestration System (e.g. <a href="https://coreos.com/operators/">CoreOS Operator Pattern</a>) and the build automation tool functionality to seamlessly spawn new Containers on top the newly built images (Continuous Delivery).</p>
<p>Official Configuration Automation artifacts for <a href="https://github.com/wso2/puppet-apim/">Puppet</a> and <a href="https://github.com/wso2/ansible-apim/">Ansible</a> for WSO2 products are available in WSO2 Github repositories. These are designed in a way that is suitable for most basic use cases, but at the same time they are easily adaptable to an increasingly complex but organizational (or even deployment) specific stories.</p>
<h3 id="generic-approach">Generic Approach</h3>
<p>Considering the above (somewhat long) list of options available, it’s easy to get lost in the details. A generic middle path approach would be to consider the 80% of the use cases and design your Docker image for that. Containers charge almost no cost in terms of compute power to kill and respawn however they incur costs in terms of management and operational complexity. Properly designed Containerization strategies should try to minimize this complexity and streamline the processes to be invisible during day-to-day operations.</p>
<p>Most use cases will strike the perfect balance between usability and Docker image size with <a href="https://github.com/wso2/docker-apim/tree/master/dockerfiles/ubuntu">Ubuntu base images</a>. Ubuntu contains most tools required to troubleshoot development user scenarios. With smart Dockerfile composition, the size of the image can be taken down to manageable levels.</p>
<p>Other than the deployable artifacts inside <code>&lt;CARBON_HOME&gt;/repository/deployment/server</code> folder, the logs files inside <code>&lt;CARBON_HOME&gt;/repository/logs</code> folder, and the instance local databases inside <code>&lt;CARBON_HOME&gt;/repository/data</code> folder, all the other product items including the scripts, configuration, and the binaries can be prebaked into the image at build time. This should ideally be done with a Configuration Automation tool like Ansible or Puppet to make use of features like environment separation, templating, and codifiability of configuration options. They will additionally make sure no unwanted, ad-hoc changes are pushed to the live systems by accident or by the need of urgency.</p>
<p>For deployable artifacts, direct NFS volumes or indirect volumes mounted in the host instance can be used to both update the running system and to do deployment synchronization where needed (e.g. WSO2 API Manager Gateway, WSO2 Enterprise Integrator, WSO2 Identity Server). Extra steps should be taken in order to make sure that these volumes are backed up properly as they will mostly be containing mission critical data that if lost would not be easily recovered or regenerated.</p>
<p>As mentioned, going with best practices adopting something like <a href="https://github.com/Yelp/dumb-init">dumb_init</a> or <a href="https://github.com/phusion/baseimage-docker/blob/rel-0.9.16/image/bin/my_init">my_init</a> will be better for Container management. This will invoke a bootstrap script that does minimal setup operations like setting environment variables, and moving deployable artifacts to correct locations from mounted locations.</p>
<p>Logs should be pushed off to a centralized log aggregator. The mechanisms to do this does not drastically differ between development and production systems. Therefore, initial time invested in setting this process up will not be wasted later.</p>
<h4 id="build-and-deployment-pipeline">Build and Deployment Pipeline</h4>
<p>As mentioned above, a build pipeline for Docker images that takes care of Continuous Integration and Continuous Delivery of the changes to live systems will force all other pieces to fall into place. It will require a repository of configurations that demands the use of a Configuration Automation tool. The build times will have to be managed. This demands proper design of the Dockerfile and the decisions on which parts of the runtime to be prebaked and which parts to be dynamically mounted, to be made early in the process. Change Review and Approval processes will come into affect once the configuration is codified. As a result of all these processes coming into perfect harmony, time to market will drastically reduce, utilizing the Container advantage to the maximum possible.</p>
<h3 id="conclusion">Conclusion</h3>
<!-- raw HTML omitted -->
<p>As evident from the above facts, the design of the Docker image will make its effect known to the top business decisions based on the operational effectiveness of the new technological stack chosen. Therefore, the minute decisions that have to be taken from how to change WSO2 server configuration to how to automatically propagate changes to the production system, have to be done so with all the details in hand.</p>
<p>The above guidelines and tips will help to go through the decision process with an informed mind. It’s not about sticking to only the vendor recommended Containerized approach, but knowing where and how to make compromises to the recommended flow in order to adapt it to suit organizational and technical requirements of the deployment. As long as the criteria within which the WSO2 Containerized deployment has to be operated are known and met, any approach that makes both the operational and business goals achievable and makes lives easier in the process is the best one.</p>
<hr>
<p>Written on December 24, 2018 by chamila de alwis.</p>
<p>Originally published on <a href="https://medium.com/@chamilad/how-to-design-a-wso2-docker-image-4c9319568670">Medium</a></p>

        </div>
        <div class="prev-next row">
	<div class="prev col-sm">
	
	<a href="https://chamila.dev/blog/2018-11-28_publishing-wso2-logs-to-splunk-from-a-containerized-deployment/">&lt; Publishing WSO2 Logs to Splunk from a Containerized Deployment</a>
		
	</div>        
	<div class="next col-sm">
	
	<a href="https://chamila.dev/blog/2019-02-15_releasing-docblock-v0.1/">Releasing DocBlock v0.1 &gt;</a>
		
	</div>
</div>


        

        

<div class="releated-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/blog/2018-11-25_cicd-apis-with-wso2-api-manager/">CI/CD APIs with WSO2 API Manager</a></li>
    
    <li><a href="/blog/2017-01-22_thinking-of-moving-your-wso2-deployment-on-to-kubernetes/">Thinking of Moving Your WSO2 Deployment On to Kubernetes?</a></li>
    
    <li><a href="/blog/2018-11-28_publishing-wso2-logs-to-splunk-from-a-containerized-deployment/">Publishing WSO2 Logs to Splunk from a Containerized Deployment</a></li>
    
  </ul>
</div>


        
        
        
        
        

        <div class="site-footer">
  

  <div class="sm-icons">
  <a href="https://chamila.dev//blog/index.xml" target="_blank" title="rss">
    <i class="fas fa-rss sm-icon"></i>
  </a>
  <a href="https://github.com/chamilad" target="_blank" title="github">
    <i class="fab fa-github sm-icon"></i>
  </a>
  <a href="https://fosstodon.org/@chamilad" target="_blank" title="fosstodon">
    <i class="fab fa-mastodon sm-icon"></i>
  </a>
</div>

  
  <div class="site-footer-item">
    Modified
    <a href="https://github.com/joway/hugo-theme-yinyang" target="_blank">YinYang</a>
    theme
  </div>
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>
<script src="/js/theme.js"></script>


<script>
  hljs.initHighlightingOnLoad();

  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>
