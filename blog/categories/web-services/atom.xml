<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web services | nuts!]]></title>
  <link href="http://chamilad.github.io/blog/categories/web-services/atom.xml" rel="self"/>
  <link href="http://chamilad.github.io/"/>
  <updated>2014-07-19T01:44:49+05:30</updated>
  <id>http://chamilad.github.io/</id>
  <author>
    <name><![CDATA[chamila de alwis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Securing a Web Service with WSO2 ESB]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/18/securing-a-web-service-with-wso2-esb/"/>
    <updated>2014-07-18T23:17:46+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/18/securing-a-web-service-with-wso2-esb</id>
    <content type="html"><![CDATA[<p>WSO2 Enterprise Service Bus is one of the <a href="http://blog.samisa.org/2014/02/wso2-esb-performance-round-75.html">best performing implementations</a> for the Enterprise market. In this article I will briefly go through what it takes to secure an unsecured backend web service using WSO2 ESB as a mediator.</p>

<p>Security in Web Services is covered by the WS-Security standard. There are <a href="http://docs.oasis-open.org/ws-sx/security-policy/examples/ws-sp-usecases-examples-cd-01.html">various policies</a> such as simple username and password authentication and PKI certificates that can be used to secure a Web Service. The policy that will be used is described using the WS-Policy standard.</p>

<p>WSDL of the secured service will have the WS-Security policy embedded and the consumer will be able to filter out the WS-Security policy from it to implement the client side security demands.</p>

<p>For this example we will be using the basic UsernameToken with Plain Text password policy which is supported right out of the box by WSO2 ESB. Note that this policy is recommended only for pre-production environments because the password is communicated in plain text. WSO2 ESB supports by default twenty security scenarios and you can always customize the policy to your liking.</p>

<h1>Pre-requisites</h1>

<ol>
<li>Unsecured backend service</li>
<li>WSO2 ESB (4.8.1 is used in this article)</li>
</ol>


<h2>Backend Service</h2>

<p>For demo purposes get a simple Web Service running. Refer to my earlier post, <a href="http://code.chamiladealwis.com/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide/">Creating a Web Service using Apache Axis2</a>, for help.</p>

<h2>Setting up WSO2 ESB</h2>

<p><a href="http://wso2.com/products/enterprise-service-bus/">Download</a> WSO2 ESB and extract it. Go to its <code>bin</code> folder and execute <code>wso2server.sh</code>. After it is executed go to the <a href="https://localhost:9443/carbon">management console</a> and log in. The default username and password is <code>admin</code>.</p>

<h1>Creating the Proxy Service</h1>

<p>We will create a proxy service for the backend service and then secure it with the UsernameToken policy.</p>

<p>Go to the ESB <a href="https://localhost:9443/carbon">management console</a> and add a proxy service by clicking on &ldquo;Proxy Service&rdquo; under Services->Add menu of the Main tab.</p>

<p><img src="/images/post_resource/esb-new-proxy.jpg"></p>

<p>Choose either &ldquo;Pass Through Proxy&rdquo; or &ldquo;WSDL Based Proxy&rdquo;. Fill the details according to the following</p>

<h2>Pass Through Proxy</h2>

<p><img src="/images/post_resource/esb-pass-through-options.jpg"></p>

<ul>
<li><p>Proxy Service Name &ndash; Enter an identifying name for the Proxy service you&rsquo;re creating.</p></li>
<li><p>Target Endpoint &ndash; Select &ldquo;Enter URL&rdquo;. &ldquo;Pick From Registry&rdquo; option allows you to select the endpoint stored as a resource on the configuration registry or the governance registry. We will be entering the endpoint URL by hand.</p></li>
<li><p>Target URL &ndash; Copy the URL of the backend service. This will be the WSDL url on the Axis2 service you created without the <code>?wsdl</code> string at the end.</p></li>
<li><p>On the &ldquo;Publish WSDL Options&rdquo; select &ldquo;Specify source URL&rdquo; for &ldquo;Publishing WSDL&rdquo;</p></li>
<li><p>WSDL URI &ndash; Enter the WSDL URL for the backend service. Click on &ldquo;Test URI&rdquo; to test the connection.</p></li>
</ul>


<p>Click Next.</p>

<h2>WSDL Proxy</h2>

<p><img src="/images/post_resource/esb-wdl-based-options.jpg"></p>

<ul>
<li><p>Proxy Service Name &ndash; Enter an identifying name for the Proxy service you&rsquo;re creating.</p></li>
<li><p>WSDL URI &ndash; The URI of the WSDL of the backend service.</p></li>
<li><p>WSDL Service &ndash; This is the service name that is used in the WSDL as the identifier for the service. In the WSDL document this is the value for the attribute <code>name</code> in the <code>wsdl:service</code> tag.</p></li>
<li><p>WSDL Port &ndash; This is the endpoint that you&rsquo;re going to use for the proxy service. Normally three types of ports are exposed for a service. Those are</p>

<ul>
<li>SOAP1.1 Endpoint &ndash; ServiceNameHttpSoap11Endpoint</li>
<li>SOAP1.2 Endpoint &ndash; ServiceNameHttpSOap12Endpoint</li>
<li>HTTP REST Endpoint &ndash; ServiceNameHttpEndpoint</li>
</ul>
</li>
</ul>


<p>Use either SOAP 1.1 or SOAP 1.2 endpoint as the port. You can find the names under the <code>&lt;wsdl:service&gt;-&gt;&lt;wsdl:port&gt;</code> tags.</p>

<p>Click Next.</p>

<p>Your proxy service will be created. WSO2 ESB has a tool called &ldquo;Try It&rdquo; which can be used as a test tool for Web Services. <a href="https://localhost:9443/carbon/service-mgt/index.jsp?region=region1&amp;item=services_list_menu">Service list page</a> will have a link to the &ldquo;Try It&rdquo; console in front of each service. Test the proxy service you just created to verify that we can go ahead to the securing phase.</p>

<p>At this point you have an unsecured proxy service that does basically nothing as a mediator to the backend service. We need to secure the service with UsernameToken policy so that the ESB will handle security aspects and only pass SOAP messages back and forth to the backend service sans the WS-Security.</p>

<h1>Securing the Proxy Service</h1>

<p>If you list the services of the ESB you will see that the proxy service you created just now is marked as unsecured, with the unlocked padlock as the icon.</p>

<p><img src="/images/post_resource/esb-unsecured-proxy.jpg"></p>

<p>Click on that icon to secure the service. Select &ldquo;Yes&rdquo; in the next page and you will be presented with the policy types that WSO2 ESB supports right out of the box.</p>

<p><img src="/images/post_resource/esb-secure-service-options.jpg"></p>

<p>Select &ldquo;UsernameToken&rdquo; and click Next.</p>

<p>Select the user groups that are allowed to use the service. In this case select admin.</p>

<p><img src="/images/post_resource/esb-secure-users-options.jpg"></p>

<p>Voilà! You have secured your proxy service. Run &ldquo;Try It&rdquo; again and enter the username and the password (in this case admin:admin) to consume the service. If you try to consume the service without entering the proper user credentials you will be presented with an AxisFault.</p>

<p>If you check the WSDL of the secured proxy service you will observe the embedded WS-Policy describing the WS-Security policy (UsernameToken in our case) in the top most part of the WSDL document. If you wish to edit this policy you can do so by selecting &ldquo;Edit Policy&rdquo; in the Policies page of the Proxy Service. I will go to details of customized policies in another article.</p>

<p>In the next article I will elaborate on how to code a client to consume the secured proxy service and how UsernameToken policy is represented in the WS-Security headers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a Web Service using Apache Axis2 [No IDE]]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide/"/>
    <updated>2014-07-01T16:38:50+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide</id>
    <content type="html"><![CDATA[<h1>Outline</h1>

<ol>
<li>Pre-requisites</li>
<li>Deploying Axis2</li>
<li>Writing the service class</li>
<li>Deploying the service</li>
<li>Verification</li>
</ol>


<h1>Pre-requisites</h1>

<p>We need Apache Axis2 running and a suitable container. You could also run Axis2 as a standalone server but for this let&rsquo;s use Tomcat as a container. So in the following order</p>

<ol>
<li>Download and install JDK7</li>
<li>Download and install Tomcat 7 (even 8 would do, but it seems as of now Tomcat 8 isn&rsquo;t being supported by Eclipse, so let&rsquo;s go with v7)</li>
<li>Download and install AXis2 on Tomcat</li>
</ol>


<h2>JDK7</h2>

<p>Download and extract the JDK tarball.</p>

<p><code>bash
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/7u60-b19/jdk-7u60-linux-x64.tar.gz
tar zxvf jdk-7u60-linux-x64.tar.gz
</code>
Add and modify the following lines in ~/.profile or /etc/profile (for system wide application) to add <code>JAVA_HOME</code> environment variable and it&rsquo;s bin folder to <code>$PATH</code>.</p>

<p><code>bash
export JAVA_HOME=/path/to/jdk/extraction
export PATH=$PATH:$HOME/bin:$JAVA_HOME/bin
</code></p>

<p>Refresh the terminal session and check if Java is working</p>

<p><code>bash
source ~/.profile
java -version
</code></p>

<h2>Tomcat 7</h2>

<p>You could install tomcat through <code>apt-get</code> or manually.</p>

<p><code>bash
sudo apt-get install tomcat7
</code></p>

<p>Or download and set paths manually.</p>

<p><code>bash
wget http://supergsego.com/apache/tomcat/tomcat-7/v7.0.54/bin/apache-tomcat-7.0.54.tar.gz
tar zxvf apache-tomcat-7.0.54.tar.gz
mv apache-tomcat-7.0.54 ~/dev/
</code></p>

<p>Add the <code>$CATALINA_HOME</code> env var to the bash profile.</p>

<p><code>bash
vi ~/.profile
</code></p>

<p>Prepend the following line before exporting the $PATH.</p>

<p><code>bash
export CATALINA_HOME=$HOME/dev/apache-tomcat-7.0.54
</code></p>

<p>Server start/stop can be done by the scripts in the <code>$CATALINA_HOME/bin</code> folder.</p>

<p><code>bash
cd $CATALINA_HOME
./bin/startup.sh
</code></p>

<h1>Deploying Axis2</h1>

<p>Download Axis2 WAR distribution and copy the web archive file to the tomcat webapps root.</p>

<p><code>bash
wget http://apache.tradebit.com/pub//axis/axis2/java/core/1.6.2/axis2-1.6.2-war.zip
unzip axis2-1.6.2-war.zip -d axis2-war
cp axis2-war/axis2.war $CATALINA_HOME/webapps/
cd $CATALINA_HOME/bin
./shutdown.sh
./startup.sh
</code></p>

<p>In the browser go to <a href="http://localhost:8080/axis2">http://localhost:8080/axis2</a>. Axis2 welcome page should appear.</p>

<h1>The Service</h1>

<p>An Axis2 archive (of <code>.aar</code> extension) has a certain directory structure not so different from a Web Archive.</p>

<p>``` bash Axis2 Archive Directory Structure start:1 linenos:false mark:4,9
.
├── SimpleService</p>

<pre><code>└─── META-INF
  └─── services.xml
└── com
  └─── chamiladealwis
    └─── ws
      └─── service
        └─── SimpleService.java
</code></pre>

<p>```</p>

<p>META-INF folder contains the services descriptor file. The other is the binary which implements the service.</p>

<p>The service class itself is a plain old Java class which exposes the services it offers through public methods. My simple service would be the following.</p>

<p>``` java SimpleService.java
package com.chamiladealwis.ws.service;</p>

<p>public class SimpleService
{</p>

<pre><code>public int add(int num1, int num2)
{
    return num1+num2;
}
</code></pre>

<p>}
```</p>

<p><code>SimpleService</code> offers just one service  named <code>add</code> which accepts two Integer parameters and returns the sum of them as an Integer.</p>

<p>Now this service needs a service descriptor which exposes the service class to Axis2 when asked.</p>

<p>``` xml services.xml mark:3
<service></p>

<pre><code>&lt;parameter name="ServiceClass" locked="false"&gt;
    com.chamiladealwis.ws.service.SimpleService
&lt;/parameter&gt;
&lt;operation name="sayHello"&gt;
    &lt;messageReceiver class="org.apache.axis2.rpc.receivers.RPCMessageReceiver" /&gt;
&lt;/operation&gt;
</code></pre>

<p></service>
<code>``
A parameter named</code>ServiceClass<code>is defined with value</code>com.chamiladealwis.ws.service.SimpleService` which the FQN of the Java class we just wrote.</p>

<p>Now compile sources, create the Axis2 archive and deploy it in the Axis Server.</p>

<p>``` bash</p>

<h1>go to the root dir and compile the sources</h1>

<p>javac com/chamiladealwis/ws/service/*.java</p>

<h1>create the archive file</h1>

<p>jar cvf SimpleService.aar *</p>

<h1>copy the archive over to the Axis2 web root</h1>

<p>cp SimpleService.aar $CATALINE_HOME/webapps/axis2/WEB-INF/services/</p>

<h1>restart tomcat</h1>

<p>cd $CATALINA_HOME/bin
./shutdown.sh
./startup.sh
```</p>

<p>Browse to <a href="http://localhost:8080/axis2/services/listServices">http://localhost:8080/axis2/services/listServices</a> in your browser and you will see <code>SimpleService</code> being listed as an availble service with <code>add</code> as an operation.</p>

<p>Click on the link to <code>SimpleService</code> to view the WSDL file which will describe the service and it&rsquo;s operation in an abstracted XML interpretation that can be used to create clients in any language to consume the service.</p>

<h1>The Client</h1>

<p>The client code has to make use of a &ldquo;Stub&rdquo; of the service which will act as a proxy and a communication agent. Axis2 binary distribution includes tools which can generate the Java stub using the WSDL file as the source.</p>

<p>Download the Axis2 binary distribution, extract it and set <code>AXIS2_HOME</code> environment variable to its root. Add <code>$AXIS2_HOME</code> to <code>$PATH</code>.</p>

<p><code>bash
wget http://apache.spinellicreations.com//axis/axis2/java/core/1.6.2/axis2-1.6.2-bin.zip
unzip axis2-1.6.2-bin.zip
pwd
</code></p>

<p>Add the <code>$AXIS2_HOME</code> variable before <code>export PATH</code> line and modify <code>$PATH</code> to include <code>$AXIS2_HOME/bin</code>.</p>

<p><code>bash
export AXIS2_HOME=/path/to/axis2/binary/folder
export PATH="$PATH:$AXIS2_HOME/bin"
</code></p>

<p>Now refresh terminal by sourcing the .profile file.</p>

<p><code>bash
source ~/.profile
echo $AXIS2_HOME
</code></p>

<p>Copy the WSDL path of the <code>SimpleService</code>, go to the directory you&rsquo;re going to create your client code and execute the following.</p>

<p><code>bash
./wsdl2java.sh -uri WSDL_PATH_OF_THE_SIMPLESERVICE -o client
</code></p>

<p>The WSDL path would be something similar to <code>http://localhost:8080/axis2/services/SimpleService?wsdl</code>.</p>

<p>This will create the Java stub and the CallbackHandler classes. The CallbackHandler class can be extended to implement custom success and error callback executions. The Stub is the class of main importance here. It contains the Request and Response types of the operations available from the Service it was generated from and the skeletol methods that call to the target endpoint once invoked. We will use these members to call our simple service.</p>

<p>```java SimpleServiceClient.java
package com.chamiladealwis.ws.client;</p>

<p>import java.rmi.RemoteException;</p>

<p>import org.apache.axis2.AxisFault;</p>

<p>import com.chamiladealwis.ws.client.SimpleServiceStub.Add;
import com.chamiladealwis.ws.client.SimpleServiceStub.AddResponse;</p>

<p>public class SimpleClient
{</p>

<pre><code>public static void main(String[] args) 
{
    try 
    {
        // Create the Stub object
        SimpleServiceStub serviceStub = new SimpleServiceStub();

        // Create the Request object. The request class is autogenerated
        // as an inner class of the Stub class.
        Add addReq = new Add();

        // Set parameters
        addReq.setNum1(4);
        addReq.setNum2(8);

        // Invoke method and get response as a response object
        AddResponse response = serviceStub.add(addReq);

        // Response object's get_return() returns the return of the remote 
        // method
        int sum = response.get_return();
        System.out.println("Sum : " + sum);
    } 
    catch (AxisFault e) 
    {
        e.printStackTrace();
    } 
    catch (RemoteException e) 
    {
        e.printStackTrace();
    }        
}
</code></pre>

<p>}
```</p>

<p>Let&rsquo;s go through the client code.</p>

<p>Consuming an operation available through a Web Service consists of following steps.</p>

<ul>
<li>Create an object of the stub. All method calls will be invoked through this object.
<code>java
SimpleServiceStub serviceStub = new SimpleServiceStub();
</code></li>
<li>Create the request object. This will have methods to add input parameters to the request.
<code>java
Add addReq = new Add();
addReq.setNum1(4);
addReq.setNum2(8);
</code></li>
<li>Invoke and the operation method. The operation method will be invoked through the stub object and the invocation accepts a parameter of type of request object.
<code>java
serviceStub.add(addReq);
</code></li>
<li>Catch the response object. The invocation will return the response object mainly containing the value returned by the operation.
<code>java
AddResponse response = serviceStub.add(addReq);
</code></li>
<li>Extract the return value. By calling <code>get_return()</code> of the response object the return value can be extracted.
<code>java
int sum = response.get_return();
</code></li>
</ul>


<p>As you see it&rsquo;s pretty straightforward, although there are couple of things to keep in mind.</p>

<ol>
<li>You have to regenerate the client stubs everytime you change most of the server code (obviously).</li>
<li>It&rsquo;s good to check if the service has been properly deployed by going to the services page and checking the WSDL generation.</li>
<li>This was a <em>simple</em> client with <em>simple</em> input and output types. When complex types are involved there are some standards to be practiced. Be mindful that Web Services operate on a language and platform agnostic environment.</li>
<li><em>You will not be writing web services and clients this way most of the time!</em> But that&rsquo;s a topic for another post :)</li>
</ol>

]]></content>
  </entry>
  
</feed>
