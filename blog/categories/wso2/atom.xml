<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: wso2 | nuts!]]></title>
  <link href="http://chamilad.github.io/blog/categories/wso2/atom.xml" rel="self"/>
  <link href="http://chamilad.github.io/"/>
  <updated>2016-02-10T13:09:00+05:30</updated>
  <id>http://chamilad.github.io/</id>
  <author>
    <name><![CDATA[chamila]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running WSO2 Products on Kubernetes]]></title>
    <link href="http://chamilad.github.io/blog/2016/02/09/running-wso2-products-on-kubernetes/"/>
    <updated>2016-02-09T16:15:13+05:30</updated>
    <id>http://chamilad.github.io/blog/2016/02/09/running-wso2-products-on-kubernetes</id>
    <content type="html"><![CDATA[<p>It&rsquo;s 2016. Kubernetes needs no introduction. Neither does WSO2, so let&rsquo;s get to the point. Let&rsquo;s run WSO2 Identity Server on Kubernetes!</p>

<h1>You&rsquo;ll need a basic understanding of</h1>

<ol>
<li><a href="https://docs.docker.com/linux/">Docker</a></li>
<li><a href="http://kubernetes.io/gettingstarted/">Kubernetes</a></li>
<li><a href="https://puppetlabs.com/presentations/getting-started-puppet">Puppet</a></li>
</ol>


<h1>Checkout</h1>

<p>the following repositories.</p>

<ol>
<li>WSO2 Kubernetes Artifacts &ndash; <code>git clone https://github.com/wso2/kubernetes-artifacts.git</code></li>
<li>WSO2 Puppet Modules &ndash; <code>git clone https://github.com/wso2/puppet-modules.git</code></li>
</ol>


<h1>The Docker Images</h1>

<p>We need to build the WSO2 IS Docker image first. For this we can take a long method of configuring the IS instance manually and then creating the Docker image with that pack or we can just save some time and let Puppet do the work. The Dockerfiles in the <a href="https://github.com/wso2/kubernetes-artifacts">WSO2 Kubernetes Artifacts repository</a> make use of <a href="https://github.com/wso2/puppet-modules">WSO2 Puppet Modules</a> to configure the server inside the Docker image.</p>

<h2>WSO2 Puppet Modules</h2>

<p>Navigate to where you checked out <a href="https://github.com/wso2/puppet-modules">WSO2 Puppet Modules</a> and build (<code>mvn clean install</code>) to get the latest WSO2 Puppet modules distribution, inside <code>target</code> folder. You can alternatively get the latest released distribution from the releases page on the <a href="https://github.com/wso2/puppet-modules/releases">GitHub repository</a>.</p>

<p>Now unzip the distribution to a place you prefer (Let&rsquo;s call this <code>&lt;PUPPET_HOME&gt;</code> here after). It&rsquo;s targeted to be unzipped directly to a Puppet Master folder (<code>/etc/puppet/</code>), so the structure of the decompressed folder looks similar to that of the inside of the Puppet Master folder.</p>

<p>WSO2 Puppet Modules heavily make use of <a href="https://docs.puppetlabs.com/hiera/1/">Hiera</a> to separate data and templates from the actual Puppet logic of configuration of the server. Therefore, the only modification that has to be done, has to be done to the Hiera YAML files and optionally the templates.</p>

<h3>Clustering</h3>

<p>Let&rsquo;s first change the clustering related data in Hiera. For this an understanding on how clustering for WSO2 products on Kubernetes is needed.</p>

<p>The Kubernetes Membership Scheme for Carbon makes use of the Kubernetes API to lookup the IP addresses of the Pods that are already up for given Kubernetes Service. For an example, for WSO2 IS, provided that the Kubernetes Service for WSO2 IS is <code>wso2is</code>, the Kubernetes Membership Scheme will make an API call to the Kubernetes API Server to find out the IP addresses of the Pods that are running. It will then update the Hazelcast instance with this list of IPs and connect to those members. When new members start, the process repeats, and the existing members get notified of its existence via Hazelcast. This membership scheme is pluggable to Hazelcast starting from Carbon 4.4.1.</p>

<p>With this understanding, lets make the changes required to enable Kubernetes Membership Scheme in WSO2 IS.</p>

<ol>
<li>Navigate to <code>&lt;PUPPET_HOME&gt;/hieradata/dev/wso2/wso2is/5.1.0/</code> and open <code>default.yaml</code> with your text editor.</li>
<li>Under <code>wso2::clustering</code> remove the <code>wka</code> related data and add the Kubernetes Membership Scheme data. The resulting section look something like the following.</li>
</ol>


<p>```yaml
wso2::clustering :</p>

<pre><code>enabled : true
#local_member_host : 127.0.0.1
#local_member_port : 4000
membership_scheme : kubernetes
#wka :
# members :
#-
#hostname : localhost
#      port : 4000
#    -
#      hostname : localhost
#      port : 4001
#multicast :
#  domain : wso2.carbon.domain
k8:
    k8_master: http://172.17.8.101:8080
    k8_namespace: default
    k8_services: wso2is
</code></pre>

<p>```</p>

<p>Note that <code>http://172.17.8.101:8080</code> is the Kubernetes API Server address. Furthermore, note that the value for <code>k8_services</code> reflects the Kubernetes Service name we are going to use later.</p>

<ol>
<li><p>We also need to add the Kubernetes Membership Scheme distribution to the <code>&lt;WSO2_SERVER_HOME&gt;/repository/components/lib</code> folder along with its dependencies. So let&rsquo;s first build the Kubernetes Membership Scheme. Navigate to where you checked out <a href="https://github.com/wso2/kubernetes-artifacts">WSO2 Kubernetes Artifacts repository</a> and to the <code>common/kubernetes-membership-scheme</code> folder inside. Build the Kubernetes Membership Scheme by running <code>mvn clean install</code>. Copy the resulting JAR file to <code>&lt;PUPPET_HOME&gt;/modules/wso2is/files/configs/repository/components/lib</code> folder. Furthermore copy the following dependencies to the same place as well.</p>

<ul>
<li><a href="http://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core/2.5.4">jackson-core-2.5.4.jar</a></li>
<li><a href="http://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind/2.5.4">jackson-databind-2.5.4.jar</a></li>
<li><a href="http://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations/2.5.4">jackson-annotations-2.5.4.jar</a></li>
</ul>
</li>
<li><p>Now let&rsquo;s specify these files inside the <code>default.yaml</code> file, so Puppet would copy them to the respective places. Add the following entry to <code>default.yaml</code>.</p></li>
</ol>


<p><code>yaml
wso2::file_list :
  - repository/components/lib/jackson-annotations-2.5.4.jar
  - repository/components/lib/jackson-core-2.5.4.jar
  - repository/components/lib/jackson-databind-2.5.4.jar
  - repository/components/lib/kubernetes-membership-scheme-1.0.0-SNAPSHOT.jar
</code></p>

<h3>Copying the Packs</h3>

<ol>
<li>Download <a href="http://wso2.com/products/identity-server/">WSO2 IS 5.1.0</a> and copy it to <code>&lt;PUPPET_HOME&gt;/modules/wso2is/files/</code> folder.</li>
<li>Download <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">JDK 1.7_80</a> and copy to <code>&lt;PUPPET_HOME&gt;/modules/wso2base/files/</code> folder.</li>
</ol>


<h2>Building the Docker image</h2>

<p>Navigate to where you checked out <a href="https://github.com/wso2/kubernetes-artifacts">WSO2 Kubernetes Artifacts repository</a>. We will be working inside this directory now.</p>

<h3>Base Image</h3>

<p>Docker images for WSO2 products make use of a base image called <code>wso2/k8s-base</code> which has to be built (or pulled from Docker Hub) before building the product images.</p>

<ol>
<li>List the Docker images in your machine.</li>
</ol>


<p><code>bash
docker images
</code>
If the list doesn&rsquo;t contain <code>wso2/k8s-base</code> Docker image you have to build it first.</p>

<ol>
<li>Navigate to <code>common/docker/base-image</code> folder, and start the Docker image build by executing <code>build.sh</code>.</li>
</ol>


<p><code>bash
./build.sh 1.0.0
</code></p>

<ol>
<li>Wait until the Docker build process completes and verify after by listing the Docker images (<code>docker images</code>) to check <code>wso2/k8s-base</code> is there.</li>
</ol>


<h3>WSO2 IS Image</h3>

<p>Navigate to <code>wso2is/docker/</code> folder. Inside you will see the Dockerfile and some Bash scripts which will make your life so much easier when it comes to building and rebuilding Docker images for test purposes.</p>

<p>The <code>build.sh</code> builder script will be looking for the <code>PUPPET_HOME</code> environment variable. So before running <code>build.sh</code> point <code>PUPPET_HOME</code> to our Puppet home. Then run the <code>build.sh</code> file by providing the Docker image version to be built and the WSO2 Carbon profiles that should be built for this product. For WSO2 IS, there is only one Carbon profile, the <code>default</code> profile. So our commands will look like something as follows.</p>

<p><code>bash
export PUPPET_HOME=~/temp/puppet
./build.sh 1.0.0 'default'
</code></p>

<p>Use sudo when executing <code>build.sh</code> if your Docker daemon needs privileged access. Here the place where we unzipped our WSO2 Puppet distribution (and modified Hiera data accordingly) is <code>~/temp/puppet</code>, and we need our Docker image to be tagged as version <code>1.0.0</code>, and we only need to build the Docker image for the <code>default</code> Carbon profile for WSO2 IS. Specifying only <code>default</code> is optional.</p>

<p>This will build the Docker image by configuring WSO2 IS using the <code>PUPPET_HOME</code> folder, and including the necessary <code>ENTRPOINT</code> scripts. List your docker images afterwards (<code>docker images</code>) and you will see something similar to the following.</p>

<p><code>bash
REPOSITORY               TAG                   IMAGE ID            CREATED             VIRTUAL SIZE
wso2/is-5.1.0            1.0.0                 c8ab0b692142        19 hours ago        1.45 GB
wso2/k8s-base            1.0.0                 2216147d6c98        22 hours ago        310.6 MB
</code></p>

<p>Next we deploy our Docker images on Kubernetes.</p>

<h1>Kubernetes Setup</h1>

<p>It would greatly help if you already have a Kubernetes cluster deployed somewhere nearby. However, it&rsquo;s safe to assume you&rsquo;re reading this just to try out this work flow, and you don&rsquo;t have a Kubernetes Cluster. In that case there are several easy options you can chose from.</p>

<h2>Kubernetes Vagrant Setup</h2>

<p><a href="http://kubernetes.io/v1.1/docs/getting-started-guides/vagrant.html">Kubernetes ships with its own Vagrantfile</a> which can make use of several Virtualization providers to quickly create a Kubernetes Cluster. You will be able to use VirtualBox as the provider and spawn a new Kubernetes cluster with one or more Nodes (previously <code>Minions</code>). However my personal experience with this has not been pleasant, because of the time it takes for the nodes to provision (SaltStack is used to provision the Fedora based nodes) and the issues it had when recreating the Cluster.</p>

<h2>github.com/pires/kubernetes-vagrant-coreos-cluster</h2>

<p><a href="https://github.com/pires/kubernetes-vagrant-coreos-cluster">This</a> is a similar setup as the above, but with several differences. First off, it uses CoreOS boxes for the Master and Node VMs. Second, it&rsquo;s really easy to destroy and recreate a cluster, in case you feel like Stalin. I keep the following short run script to start the cluster.</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>export NODES=1
export USE_KUBE_UI=true</p>

<p>vagrant up
```
This starts a Kubernetes Cluster with one Master and one Node VM, with IPs 172.17.8.101 and 172.17.8.102 each respectively.</p>

<h2>Any Other Options?</h2>

<p>Well, I can copy paste the Kubernetes documentation here, or you can simply <a href="http://kubernetes.io/v1.1/docs/getting-started-guides/README.html">go there and read</a> the other options you have, which tend to demand a little bit of commitment. So if you&rsquo;re afraid of that better stick to the Vagrant setups above.</p>

<h1>WSO2 IS Cluster</h1>

<p>We built the Docker images, and now we have a Kubernetes Cluster. The next logical step is to go ahead and deploy the Docker image on top of the Kubernetes Cluster. To do that we need to do the following.</p>

<ol>
<li>Either upload the WSO2 IS Docker image to an accessible Docker registry or load it to the Nodes' Docker registry (If you created a Vagrant setup for Kubernetes, the easier option would be to compress the WSO2 IS Docker image to a tar file, scp it to the Node/s and Load the tar to the local Docker registry)</li>
<li>Deploy a Replication Controller for WSO2 IS Docker image, with a replica count.</li>
<li>Deploy a Kubernetes Service for the WSO2 IS Pods</li>
<li>???</li>
<li>Profit</li>
</ol>


<h2>Load Docker image</h2>

<p>Let&rsquo;s load our Docker image to the Node/s. You can run the <code>save.sh</code> file inside <code>wso2is/docker/</code> folder. It will save the Docker image to <code>~/docker/images/</code> folder as <code>.tar</code> file. Or you can simply call <code>docker save</code> and create the <code>.tar</code> file yourself.</p>

<p>```bash
docker save wso2/is-5.1.0:1.0.0 > wso2is-5.1.0-1.0.0.tar</p>

<h1>insecure_private_key is the key to use to ssh inside the Vagrant boxes, 172.17.8.102 is the Node&rsquo;s IP</h1>

<p>scp -i ~/.vagrant.d/insecure_private_key wso2is-5.1.0-1.0.0.tar core@172.17.8.102:.</p>

<h1>ssh to the node and load the Docker image</h1>

<p>vagrant ssh node-01
docker load &lt; wso2is-5.1.0-1.0.0.tar
docker images # to verify the image was loaded successfully
```</p>

<h2>Replication Controller</h2>

<p>A Replication Controller makes sure that a specified number of Pods will always be there in the Cluster. We specify the Docker image to use, the number of replicas to maintain, and the labels that should be applied to the Pods. You can find the Replication Controller for WSO2 IS in <code>wso2is/kubernetes/wso2is-controller.yaml</code>. It looks something like the following.</p>

<p>```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: wso2is
  labels:</p>

<pre><code>name: wso2is
</code></pre>

<p>spec:
  replicas: 1
  selector:</p>

<pre><code>name: wso2is
</code></pre>

<p>  template:</p>

<pre><code>metadata:
  labels:
    name: wso2is
spec:
  containers:
  - name: wso2is
    image: wso2/is-5.1.0:1.0.0
    ports:
    -
      containerPort: 9763
      protocol: "TCP"
    -
      containerPort: 9443
      protocol: "TCP"
    -
      containerPort: 8000
      protocol: "TCP"
    -
      containerPort: 10500
      protocol: "TCP"
</code></pre>

<p><code>``
Here, we have specified the image to use as</code>wso2/is-5.1.0:1.0.0`. If you built your image with a different name, change this value. Also, we have specified the number of replicas to be just one.</p>

<p>Let&rsquo;s deploy the Replication Controller. (If you used the Vagrant Setup, you can directly use the <code>deploy.sh</code> script included along with the Replication Controller in the same folder. It will also deploy the Service artifact and wait until the WSO2 IS server to come up, so for the purpose of understanding the process, let&rsquo;s manually deploy the artifacts separately.)</p>

<p><code>bash
kubectl create -f wso2is-controller.yaml
</code>
If you get an error like the following, it means that kubectl cannot find the Kubernetes API Server to communicate with it. So you have to point out where the API Server is to the kubectl.</p>

<p><code>bash
kubectl create -f wso2is-controller.yaml
error: couldn't read version from server: Get http://localhost:8080/api: dial tcp 127.0.0.1:8080: connection refused
export KUBERNETES_MASTER=http://172.17.8.101:8080 #If your Kubernetes Master IP and Port is different, change this accordingly
</code>
On the other hand if your system simply doesn&rsquo;t have kubectl installed, you first need to <a href="http://kubernetes.io/v1.1/docs/user-guide/prereqs.html">install it</a>.</p>

<p>If everything went right Kubernetes will spawn a Pod with a WSO2 IS container inside it, in one of the Nodes. You can get the list of Pods deployed by issueing <code>kubectl get pods</code>.</p>

<h2>Kubernetes Service</h2>

<p>To expose the WSO2 IS container from Kubernetes, we need to define a Service which maps the operational ports of the WSO2 IS container with ports on the Nodes. For this we need to specify a selector for the Pods that should be served through the Service and the port mapping. You can find the following Service definition in <code>wso2is/kubernetes/wso2is-service.yaml</code> file.</p>

<p>```yaml
apiVersion: v1
kind: Service
metadata:
  labels:</p>

<pre><code>name: wso2is
</code></pre>

<p>  name: wso2is
spec:
  type: NodePort
  sessionAffinity: ClientIP
  ports:</p>

<pre><code># ports that this service should serve on
-
  name: 'servlet-http'
  port: 9763
  targetPort: 9763
  nodePort: 32001
-
  name: 'servlet-https'
  port: 9443
  targetPort: 9443
  nodePort: 32002
-
  name: 'kdc-server'
  port: 8000
  targetPort: 8000
  nodePort: 32003
-
  name: 'thrift-entitlement'
  port: 10500
  targetPort: 10500
  nodePort: 32004
</code></pre>

<p>  # label keys and values that must match in order to receive traffic for this service
  selector:</p>

<pre><code>name: wso2is
</code></pre>

<p>```</p>

<p>In this service we have exposed port 9443 of the WSO2 IS container through the port 32002 on the Node. Since the type of the Service is <code>NodePort</code>, the port 32002 on all of the Nodes will be mapped to the port 9443 of the container. Another interesting thing to note is that we have specified <code>metadata:name</code> as <code>wso2is</code> which is the same name we provided for <code>k8_services</code> when we configured the Kubernetes Membership Scheme earlier.</p>

<p>Let&rsquo;s deploy this Service.</p>

<p><code>bash
kubectl create -f wso2is-service.yaml
kubectl get svc
</code></p>

<h1>Accessing WSO2 IS</h1>

<p>Now we have a WSO2 IS container Cluster on Kubernetes. How are we going to access it? Simple. We just access any Node on the port 32002 to access the Carbon Console. For example, in the Vagrant Setup, we can access the Carbon console by going to <code>https://172.17.8.102:32002/carbon</code>. You can read more about the <a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#type-nodeport">NodePort</a> type Services to understand what is happening here.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Consuming a Service Secured by WSO2 ESB]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/19/consuming-a-service-secured-by-wso2-esb/"/>
    <updated>2014-07-19T18:27:13+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/19/consuming-a-service-secured-by-wso2-esb</id>
    <content type="html"><![CDATA[<p>In the <a href="http://code.chamiladealwis.com/blog/2014/07/18/securing-a-web-service-with-wso2-esb/">last post</a> I explained the steps needed, although somewhat minimal, to secure an unsecured backend service with WSO2 ESB. In this post I will continue on to the client side of the communication explaining the minimal client needed to communicate with the secure proxy service we created and take a peak at the action going on under the hood.</p>

<h1>UsernameToken</h1>

<p>Before we dive in to the client side code let&rsquo;s take a look at the WS-Policy for the UsernameToken security we applied to our service.</p>

<p>Login to the WSO2 ESB <a href="https://localhost:9443/carbon">Management console</a> and go to the Proxy service we created. In the &ldquo;Quality of Service Configuration&rdquo; section there is a link to &ldquo;Policies&rdquo;. Go to it and click in the &ldquo;Edit Policy&rdquo; button in front of the SOAP12Binding sub section.</p>

<p>What we are interested here is the content inside the <code>&lt;sp:SignedSupportingTokens xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;</code> tag. This describes the authentication policy that is applied to the proxy service. Since we applied UsernameToken the content will be similar to the following.</p>

<p>```xml
&lt;sp:SignedSupportingTokens xmlns:sp=&ldquo;<a href="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy">http://schemas.xmlsoap.org/ws/2005/07/securitypolicy</a>&rdquo;></p>

<pre><code>&lt;wsp:Policy&gt;
   &lt;sp:UsernameToken sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;&lt;/sp:UsernameToken&gt;
&lt;/wsp:Policy&gt;
</code></pre>

<p> &lt;/sp:SignedSupportingTokens>
```</p>

<p>This policy is embedded in the WSDL of the secured proxy service we created so the consuming party can derive the security demands of the service from it.</p>

<h1>Writing the Java Client</h1>

<p>To access the secure proxy service the following requirements should be satisfied.</p>

<ol>
<li>The server certificate should be added to the trust store.</li>
<li>Axis2 modules and libraries of Apache Rampart and its dependencies should be provided</li>
<li>The username and the password for the account which is granted access to the proxy service should be provided.</li>
</ol>


<h2>Adding the certificate to the trust store</h2>

<p>As you might be aware in HTTPS the server has to provide a self-signed or CA signed certificate for its secure communication and the client has to add that certificate as trusted to its trust store. WSO2Carbon products come with a self-signed certificate and you can add that certificate to your trust store to initiate secure communication. For demo purposes we&rsquo;ll use the same trust store that WSO2 ESB uses so you will not be needing to extract and import the certificate to your own trust store.</p>

<p>In case you&rsquo;re using your own trust store, <a href="http://udaraliyanage.wordpress.com/2014/06/14/convert-wso2carbon-jks-into-pem-format-extract-certificate-and-private-key/">this article</a> by Udara Liyanage describes how to extract the server certificate from the keystore. After the certificate is extracted add it to your trust store. For this you can use the keytool command as follows.</p>

<p><code>bash
keytool -import -alias wso2_esb_server -file /path/to/server-certificate-file.crt -keystore /path/to/trust-store.jks -storepass truststorepassword
</code>
You can use your own trust store and set the path to the keystore file in the code or you can use the Java runtime trust store which is located in <code>$JRE_HOME/lib/security</code>.</p>

<p>To verify that the certificate was added you can grep the list of certificates in the trust store.</p>

<p><code>bash
keytool -list -keystore /path/to/trust-store.jks -storepass truststorepassword | grep wso2_esb_server
</code></p>

<h2>Apache Rampart</h2>

<p>Apache Rampart handles the security aspects in Axis2 and is needed to make use of WS-Security.</p>

<p><a href="http://axis.apache.org/axis2/java/rampart/download.html">Download Rampart</a> and extract the zip file.</p>

<p>Inside the lib folder the rampart library and its dependencies are contained. Inside the modules folder rampart and rahas Axis2 modules are contained. Rampart libraries should be available in the Classpath of the Java client we are going to execute while the Rampart Axis2 modules should be available in an Axis2 repository.</p>

<p><a href="http://wso2.com/library/tutorials/axis2-repository/">An Axis2 repository</a> consist of the following folder structure.</p>

<p>```
└── repository
    ├── modules
    ├── services
    └── conf</p>

<pre><code>   └── axis2.xml
</code></pre>

<p>```</p>

<p>If you&rsquo;ve downloaded and extracted Axis2 to be used as a standalone Axis2 server then you can use that location. Copy the module archive (.mar) files from the extracted rampart folder to the repository/modules folder.</p>

<p>In the client code we will be engaging the Rampart module to handle the WS-Security headers.</p>

<h2>Client Code</h2>

<p>Assuming the service and the operations described in the <a href="http://code.chamiladealwis.com/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide/">&ldquo;Creating a Web Service using Apache Axis2&rdquo;</a> article the following Java client can be used to access the secured proxy service.</p>

<p>Create the Stub and the CallbackHandler classes using the <code>wsdl2java</code> tool as described in the above mentioned article. You must use the WSDL of the secured proxy service for source generation. Then code the client as follows. Replace <code>ESB_HOME</code> and <code>AXIS2_HOME</code> with your own locations.</p>

<p>```java</p>

<p>package com.chamiladealwis.ws.client;</p>

<p>import java.rmi.RemoteException;</p>

<p>import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;</p>

<p>public class SimpleServiceSecureClient {</p>

<pre><code>public static void main(String[] args) {
    try {

        // set trust store path and password. 
        System.setProperty("javax.net.ssl.trustStore",
                "ESB_HOME/repository/resources/security/client-truststore.jks");
        System.setProperty("javax.net.ssl.trustStorePassword", "wso2carbon");

        // create the configuration context from an axis repository. 
        ConfigurationContext ctx =
                               ConfigurationContextFactory.createConfigurationContextFromFileSystem("AXIS2_HOME/repository",null);

        SimpleServiceExampleProxyStub secureStub = new SimpleServiceExampleProxyStub(ctx);

        // set username and password to access the service
        secureStub._getServiceClient().getOptions().setUserName("admin");
        secureStub._getServiceClient().getOptions().setPassword("admin");

        // engage rampart module to set WS-Security headers.
        secureStub._getServiceClient().engageModule("rampart");

        // execute remote call
        SimpleServiceExampleProxyStub.Add addReq = new SimpleServiceExampleProxyStub.Add();
        addReq.setNum1(45);
        addReq.setNum2(53);

        SimpleServiceExampleProxyStub.AddResponse addResponse = secureStub
                .add(addReq);

        System.out.println("Response received : " + addResponse.get_return());

    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
```</p>

<p>We have used the trust store that WSO2 ESB uses so we will not have to import the certificate used by the server.</p>

<p>```java
System.setProperty(&ldquo;javax.net.ssl.trustStore&rdquo;,</p>

<pre><code>    "ESB_HOME/repository/resources/security/client-truststore.jks");
</code></pre>

<p>System.setProperty(&ldquo;javax.net.ssl.trustStorePassword&rdquo;, &ldquo;wso2carbon&rdquo;);
```</p>

<p>The ConfigurationContext is generated from the repository location. We have copied the Rampart and Rahas Axis2 modules to this repository to be used when later engageModule(&ldquo;rampart&rdquo;) is called.</p>

<p>```java
ConfigurationContext ctx = ConfigurationContextFactory.createConfigurationContextFromFileSystem(&ldquo;AXIS2_HOME/repository&rdquo;,null);</p>

<p>SimpleServiceExampleProxyStub secureStub = new SimpleServiceExampleProxyStub(ctx);</p>

<p>&hellip;.
secureStub._getServiceClient().engageModule(&ldquo;rampart&rdquo;);
```</p>

<p>The username and the password to the account that is allowed to use the secured proxy service is included.</p>

<p><code>java
secureStub._getServiceClient().getOptions().setUserName("admin");
secureStub._getServiceClient().getOptions().setPassword("admin");
</code></p>

<p>Note that this code works with SOAP messages and WS-* standards. If you want to use the REST communication method use the following code. This code does not make use of Rampart module since authentication is done using HTTP Authorization header (Basic auth mechanism since we&rsquo;ve used UsernameToken policy in our proxy service).</p>

<p>```java
package com.chamiladealwis.ws.client;</p>

<p>import java.rmi.RemoteException;</p>

<p>import org.apache.axis2.Constants;
import org.apache.axis2.transport.http.HTTPConstants;
import org.apache.axis2.transport.http.HttpTransportProperties;
import org.apache.axis2.transport.http.HttpTransportProperties.Authenticator;</p>

<p>public class SimpleServiceSecureClient {</p>

<pre><code>public static void main(String[] args) {
    try {
        System.setProperty("javax.net.ssl.trustStore",
                "/home/chamilad/dev/wso2esb-4.8.1/repository/resources/security/client-truststore.jks");
        System.setProperty("javax.net.ssl.trustStorePassword", "wso2carbon");

        SimpleServiceExampleProxyStub secureStub = new SimpleServiceExampleProxyStub();

        // set credentials to the secure proxy service
        HttpTransportProperties.Authenticator authenticator = new Authenticator();
        authenticator.setUsername("admin");
        authenticator.setPassword("admin");
        secureStub._getServiceClient().getOptions().setProperty(HTTPConstants.AUTHENTICATE, authenticator);
        secureStub._getServiceClient().getOptions().setProperty(Constants.Configuration.ENABLE_REST, Constants.VALUE_TRUE);

        // execute remote call
        SimpleServiceExampleProxyStub.Add addReq = new SimpleServiceExampleProxyStub.Add();
        addReq.setNum1(45);
        addReq.setNum2(53);

        SimpleServiceExampleProxyStub.AddResponse addResponse = secureStub
                .add(addReq);

        System.out.println("Response received : " + addResponse.get_return());
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
```</p>

<p>Now get the backend service and the WSO2 ESB running and execute the client to see the results. If you use Wireshark or TCPMon you will observe that the communication between the client and the ESB is encrypted and thus not visible to outsiders while the communication between the ESB and the backend service is unencrypted.</p>

<h2>&ldquo;Unable to engage module : rampart&rdquo;</h2>

<p>If you get an error with the message &ldquo;Unable to engage module : rampart&rdquo; it is most likely because Axis2 cannot find the Rampart module archive files. Verify the following and try again.</p>

<ul>
<li>See that the repository location specified when creating the ConfigurationContext contains rampart<em>.mar and rahas</em>.mar files in the modules folder.</li>
<li>Check the Classpath locations to verify that rampart*.jar files are available.</li>
</ul>


<h1>Action Under the Hood</h1>

<p>Let us investigate the SOAP/REST messages that are used to communicate with the secured proxy service.</p>

<p>I used <a href="http://www.charlesproxy.com/documentation/proxying/ssl-proxying/">Charles Proxy</a> to capture the encrypted communication between the client and the ESB. For some reason (I&rsquo;m guessing <a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">this</a> to be the reason, but this is still to be verified. The cipher suite mentioned in the Server Hello packet is TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA.) Wireshark couldn&rsquo;t decrypt the captured packets even when the server&rsquo;s private key was provided. Charles Proxy can make use of SSL Proxying in which it produces its own certificates based on its root certificate to communicate as a man in the middle. Charles' root certificate should be added to the trust store that is used in our client.</p>

<p>The SOAP message that is sent from our client consists of the following SOAP header.</p>

<p>```xml
&lt;soapenv:Header></p>

<pre><code>&lt;wsse:Security xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" soapenv:mustUnderstand="true"&gt;
    &lt;wsu:Timestamp wsu:Id="TS-1"&gt;
        &lt;wsu:Created&gt;2014-08-02T09:00:56.439Z&lt;/wsu:Created&gt;
        &lt;wsu:Expires&gt;2014-08-02T09:05:56.439Z&lt;/wsu:Expires&gt;
    &lt;/wsu:Timestamp&gt;
    &lt;wsse:UsernameToken wsu:Id="UsernameToken-2"&gt;
        &lt;wsse:Username&gt;admin&lt;/wsse:Username&gt;
        &lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"&gt;admin&lt;/wsse:Password&gt;
    &lt;/wsse:UsernameToken&gt;
&lt;/wsse:Security&gt;
</code></pre>

<p>&lt;/soapenv:Header>
```</p>

<p>Notice the username and the password fields? Yes, the password is sent in plaint text over HTTPS therefore if somehow HTTPS is compromised the password will be visible. To overcome this the WS-Policy for WS-Security can be <a href="http://soasecurity.org/2014/03/19/securing-a-proxy-service-in-wso2-esb-1-1-using-hash-passwords-in-username-token">modified to use a password digest</a> instead of a plain text password.</p>

<p>The function of <code>&lt;wsu:Timestamp&gt;</code>, which in short is to prevent replay attacks, is best described <a href="http://hasini-gunasinghe.blogspot.com/2012/02/timestamp-in-ws-security-to-mitigate.html">here</a>.</p>

<p>WSO2 ESB will process and strip the WSSE:Security header from the message to forward it to the backend service. When the response comes from the backend service ESB will add the related WS-Security headers to the outgoing message.</p>

<p>```xml
&lt;soapenv:Header></p>

<pre><code>&lt;wsse:Security xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" soapenv:mustUnderstand="true"&gt;
    &lt;wsu:Timestamp xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="Timestamp-26"&gt;
        &lt;wsu:Created&gt;2014-08-02T09:00:56.704Z&lt;/wsu:Created&gt;
        &lt;wsu:Expires&gt;2014-08-02T09:05:56.704Z&lt;/wsu:Expires&gt;
    &lt;/wsu:Timestamp&gt;
&lt;/wsse:Security&gt;
</code></pre>

<p>&lt;/soapenv:Header>
```</p>

<p>If you used REST instead of SOAP you will see the following HTTP headers in the outgoing message from your client.</p>

<p>```
POST /services/SimpleServiceSecureExampleProxy.SimpleServiceSecureExampleProxyHttpsSoap12Endpoint HTTP/1.1
Content-Type: application/xml; charset=UTF-8
SOAPAction: urn:getItemsAvailable
User-Agent: Axis2
Transfer-Encoding: chunked
Host: hostname:8243
Authorization: Basic YWRtaW46YWRtaW4=
Content-Length: 101</p>

<p>&lt;ns1:add xmlns:ns1=&ldquo;<a href="http://client.ws.chamiladealwis.com">http://client.ws.chamiladealwis.com</a>&rdquo;></p>

<pre><code>&lt;ns1:num1&gt;45&lt;/ns1:itemName&gt;
&lt;ns1:num2&gt;53&lt;/ns1:clarkName&gt;
</code></pre>

<p>&lt;/ns1:add>
```</p>

<p>Note the HTTP &ldquo;Authorization&rdquo; header and the value &ldquo;Basic&rdquo;. The value after &ldquo;Basic&rdquo; is the base64 encoded string containing the username:password. You can decrypt the encoded string to verify this using any <a href="http://www5.rptea.com/base64/">online tool</a>.</p>

<p>There are many policies that can be used to secure a proxy service, and UsernameToken is just the simplest form. More complex policies involve defining custom password callback handlers to refer to resources like federated identity to authenticate server calls. UsernameToken deals with plain text passwords so it should be only used for development purposes and not for production.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Securing a Web Service with WSO2 ESB]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/18/securing-a-web-service-with-wso2-esb/"/>
    <updated>2014-07-18T23:17:46+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/18/securing-a-web-service-with-wso2-esb</id>
    <content type="html"><![CDATA[<p>WSO2 Enterprise Service Bus is one of the <a href="http://blog.samisa.org/2014/02/wso2-esb-performance-round-75.html">best performing implementations</a> for the Enterprise market. In this article I will briefly go through what it takes to secure an unsecured backend web service using WSO2 ESB as a mediator.</p>

<p>Security in Web Services is covered by the WS-Security standard. There are <a href="http://docs.oasis-open.org/ws-sx/security-policy/examples/ws-sp-usecases-examples-cd-01.html">various policies</a> such as simple username and password authentication and PKI certificates that can be used to secure a Web Service. The policy that will be used is described using the WS-Policy standard.</p>

<p>WSDL of the secured service will have the WS-Security policy embedded and the consumer will be able to filter out the WS-Security policy from it to implement the client side security demands.</p>

<p>For this example we will be using the basic UsernameToken with Plain Text password policy which is supported right out of the box by WSO2 ESB. Note that this policy is recommended only for pre-production environments because the password is communicated in plain text. WSO2 ESB supports by default twenty security scenarios and you can always customize the policy to your liking.</p>

<h1>Pre-requisites</h1>

<ol>
<li>Unsecured backend service</li>
<li>WSO2 ESB (4.8.1 is used in this article)</li>
</ol>


<h2>Backend Service</h2>

<p>For demo purposes get a simple Web Service running. Refer to my earlier post, <a href="http://code.chamiladealwis.com/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide/">Creating a Web Service using Apache Axis2</a>, for help.</p>

<h2>Setting up WSO2 ESB</h2>

<p><a href="http://wso2.com/products/enterprise-service-bus/">Download</a> WSO2 ESB and extract it. Go to its <code>bin</code> folder and execute <code>wso2server.sh</code>. After it is executed go to the <a href="https://localhost:9443/carbon">management console</a> and log in. The default username and password is <code>admin</code>.</p>

<h1>Creating the Proxy Service</h1>

<p>We will create a proxy service for the backend service and then secure it with the UsernameToken policy.</p>

<p>Go to the ESB <a href="https://localhost:9443/carbon">management console</a> and add a proxy service by clicking on &ldquo;Proxy Service&rdquo; under Services->Add menu of the Main tab.</p>

<p><img src="/images/post_resource/esb-new-proxy.jpg"></p>

<p>Choose either &ldquo;Pass Through Proxy&rdquo; or &ldquo;WSDL Based Proxy&rdquo;. Fill the details according to the following</p>

<h2>Pass Through Proxy</h2>

<p><img src="/images/post_resource/esb-pass-through-options.jpg"></p>

<ul>
<li><p>Proxy Service Name &ndash; Enter an identifying name for the Proxy service you&rsquo;re creating.</p></li>
<li><p>Target Endpoint &ndash; Select &ldquo;Enter URL&rdquo;. &ldquo;Pick From Registry&rdquo; option allows you to select the endpoint stored as a resource on the configuration registry or the governance registry. We will be entering the endpoint URL by hand.</p></li>
<li><p>Target URL &ndash; Copy the URL of the backend service. This will be the WSDL url on the Axis2 service you created without the <code>?wsdl</code> string at the end.</p></li>
<li><p>On the &ldquo;Publish WSDL Options&rdquo; select &ldquo;Specify source URL&rdquo; for &ldquo;Publishing WSDL&rdquo;</p></li>
<li><p>WSDL URI &ndash; Enter the WSDL URL for the backend service. Click on &ldquo;Test URI&rdquo; to test the connection.</p></li>
</ul>


<p>Click Next.</p>

<h2>WSDL Proxy</h2>

<p><img src="/images/post_resource/esb-wdl-based-options.jpg"></p>

<ul>
<li><p>Proxy Service Name &ndash; Enter an identifying name for the Proxy service you&rsquo;re creating.</p></li>
<li><p>WSDL URI &ndash; The URI of the WSDL of the backend service.</p></li>
<li><p>WSDL Service &ndash; This is the service name that is used in the WSDL as the identifier for the service. In the WSDL document this is the value for the attribute <code>name</code> in the <code>wsdl:service</code> tag.</p></li>
<li><p>WSDL Port &ndash; This is the endpoint that you&rsquo;re going to use for the proxy service. Normally three types of ports are exposed for a service. Those are</p>

<ul>
<li>SOAP1.1 Endpoint &ndash; ServiceNameHttpSoap11Endpoint</li>
<li>SOAP1.2 Endpoint &ndash; ServiceNameHttpSOap12Endpoint</li>
<li>HTTP REST Endpoint &ndash; ServiceNameHttpEndpoint</li>
</ul>
</li>
</ul>


<p>Use either SOAP 1.1 or SOAP 1.2 endpoint as the port. You can find the names under the <code>&lt;wsdl:service&gt;-&gt;&lt;wsdl:port&gt;</code> tags.</p>

<p>Click Next.</p>

<p>Your proxy service will be created. WSO2 ESB has a tool called &ldquo;Try It&rdquo; which can be used as a test tool for Web Services. <a href="https://localhost:9443/carbon/service-mgt/index.jsp?region=region1&amp;item=services_list_menu">Service list page</a> will have a link to the &ldquo;Try It&rdquo; console in front of each service. Test the proxy service you just created to verify that we can go ahead to the securing phase.</p>

<p>At this point you have an unsecured proxy service that does basically nothing as a mediator to the backend service. We need to secure the service with UsernameToken policy so that the ESB will handle security aspects and only pass SOAP messages back and forth to the backend service sans the WS-Security.</p>

<h1>Securing the Proxy Service</h1>

<p>If you list the services of the ESB you will see that the proxy service you created just now is marked as unsecured, with the unlocked padlock as the icon.</p>

<p><img src="/images/post_resource/esb-unsecured-proxy.jpg"></p>

<p>Click on that icon to secure the service. Select &ldquo;Yes&rdquo; in the next page and you will be presented with the policy types that WSO2 ESB supports right out of the box.</p>

<p><img src="/images/post_resource/esb-secure-service-options.jpg"></p>

<p>Select &ldquo;UsernameToken&rdquo; and click Next.</p>

<p>Select the user groups that are allowed to use the service. In this case select admin.</p>

<p><img src="/images/post_resource/esb-secure-users-options.jpg"></p>

<p>Voilà! You have secured your proxy service. Run &ldquo;Try It&rdquo; again and enter the username and the password (in this case admin:admin) to consume the service. If you try to consume the service without entering the proper user credentials you will be presented with an AxisFault.</p>

<p>If you check the WSDL of the secured proxy service you will observe the embedded WS-Policy describing the WS-Security policy (UsernameToken in our case) in the top most part of the WSDL document. If you wish to edit this policy you can do so by selecting &ldquo;Edit Policy&rdquo; in the Policies page of the Proxy Service. I will go to details of customized policies in another article.</p>

<p>In the next article I will elaborate on how to code a client to consume the secured proxy service and how UsernameToken policy is represented in the WS-Security headers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSO2 ESB Sample Screw Ups]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/07/wso2-esb-sample-screw-ups/"/>
    <updated>2014-07-07T12:26:35+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/07/wso2-esb-sample-screw-ups</id>
    <content type="html"><![CDATA[<p>We all know the feeling when we follow every instruction of a sample page to the letter and the results turn out to be a total <del>clusterf..</del> disaster.</p>

<p>Well, let me try to easy some of the pain by listing the following probable fixes and workarounds for the 100-odd samples of the renowned <a href="http://wso2.com/products/enterprise-service-bus/">WSO2 Enterprise Service Bus</a>.</p>

<blockquote><p>Keep in mind that this post will keep getting updated till I go through every sample.</p></blockquote>

<h1>Sample 50</h1>

<p>The synapse configuration file that is shipped with 4.8.1 has an error where asterisks are missing from a filter mediater regex. Therefore execution of the main sequence stops after failing to match any <code>To</code> SOAP headers.</p>

<h2>Fix</h2>

<p>Change the following line in <code>&lt;ESB_HOME&gt;/repository/samples/synapse_sample_50.xml</code> to include the asterisks.</p>

<p><code>xml
&lt;filter source="get-property('To')" regex="./StockQuote."&gt;
</code>
The modified line should be as follows.</p>

<p><code>xml
&lt;filter source="get-property('To')" regex=".*/StockQuote.*"&gt;
</code></p>

<h1>Sample 57</h1>

<p>In ESB 4.8.1 running this sample would not result in the expected outcome and would throw an error similar to the following.</p>

<p><code>
org.apache.synapse.SynapseException: A LoadBalanceEventHandler has not been
specified in the axis2.xml file for the domain apache.axis2.application.domain
at
org.apache.synapse.core.axis2.Axis2LoadBalanceMembershipHandler.setConfigurationContext(Axis2LoadBalanceMembershipHandler.java:77)
</code></p>

<p>The reason for this is the incompatibility between the clustering mechanisms used in ESB 4.8.1 (HazelCast) and the sample Axis2 server (Apache Tribes) it ships with.</p>

<h2>Fix</h2>

<p>As <a href="http://wso2-oxygen-tank.10903.n7.nabble.com/Dev-Running-ESB-sample-57-td89484.html">this</a> email thread mentions this can be overcome by getting ESB 4.7.0 where the same clustering implementation is used that of the Axis2 server.</p>

<h1>Sample 60, 61, 62</h1>

<p>In ESB 4.8.1 the synapse configuration files for the samples 60, 61, and 62 are missing and the configurations that are on the sample pages are errorneous.
For an example in sample #61 the mentioned configuration refers to a property named <code>EP_LIST</code> while there&rsquo;s no external registry resource or inline defined property that is of the name EP_LIST.</p>

<p>```xml
<send></p>

<pre><code>&lt;endpoint&gt;
    &lt;recipientlist&gt;
        &lt;endpoints value="{get-property('EP_LIST')}" max-cache="20" /&gt;
    &lt;/recipientlist&gt;
&lt;/endpoint&gt;
</code></pre>

<p></send>
```</p>

<h2>Fix</h2>

<p>However these synapse configuration files are present in the 4.7.0 release and they can be used to start the 4.8.1 ESB with the desired configuration.</p>

<h1>Sample 152</h1>

<p>You would probably get an error while trying to execute the client like the following.</p>

<p>```
[2014-07-07 13:28:09,060] ERROR &ndash; ServerWorker Error processing POST request
java.lang.NullPointerException: Tenant domain has not been set in CarbonContext</p>

<pre><code>at org.wso2.carbon.caching.impl.CacheManagerFactoryImpl.getCacheManager(CacheManagerFactoryImpl.java:79)
at org.wso2.carbon.security.pox.POXSecurityHandler.getPOXCache(POXSecurityHandler.java:383)
at org.wso2.carbon.security.pox.POXSecurityHandler.invoke(POXSecurityHandler.java:179)
at org.apache.axis2.engine.Phase.invokeHandler(Phase.java:340)
at org.apache.axis2.engine.Phase.invoke(Phase.java:313)
at org.apache.axis2.engine.AxisEngine.invoke(AxisEngine.java:261)
at org.apache.axis2.engine.AxisEngine.receive(AxisEngine.java:167)
at org.apache.axis2.transport.http.HTTPTransportUtils.processHTTPPostRequest(HTTPTransportUtils.java:172)
at org.apache.synapse.transport.nhttp.ServerWorker.processEntityEnclosingMethod(ServerWorker.java:459)
at org.apache.synapse.transport.nhttp.ServerWorker.run(ServerWorker.java:279)
at org.apache.axis2.transport.base.threads.NativeWorkerPool$1.run(NativeWorkerPool.java:172)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
at java.lang.Thread.run(Thread.java:722)
</code></pre>

<p>```</p>

<p>While I can&rsquo;t exactly pinpoint the cause of the error this happens due to the way we execute the samples. If you directly executed the sample #152 chances are that you wouldn&rsquo;t come across this. But if you started with a sample before #101 you&rsquo;d probably get this.</p>

<p>At sample #101 you have to enable the NHTTP configuration for Carbon. Non-Blocking HTTP is required to enable WS-ReliableMessaging so that the source can call the Web Service destination asynchronously.</p>

<p>You are instructed to enable NHTTP configuration by editing the <code>carbon.xml</code> file in <code>&lt;ESB_HOME&gt;/repository/conf/</code>.</p>

<p>```xml carbon.xml start:253</p>

<!-- You are instructed to comment this line and enable the next one to enable NHTTP -->


<p><ConfigurationFile>${carbon.home}/repository/conf/axis2/axis2.xml</ConfigurationFile>                                                                                                                         <br/>
<ConfigurationFile>${carbon.home}/repository/conf/axis2/axis2_nhttp.xml</ConfigurationFile>
```</p>

<h2>Fix</h2>

<p>To make the sample #152 run properly revert this change.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a Web Service using Apache Axis2 [No IDE]]]></title>
    <link href="http://chamilad.github.io/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide/"/>
    <updated>2014-07-01T16:38:50+05:30</updated>
    <id>http://chamilad.github.io/blog/2014/07/01/creating-a-web-service-using-apache-axis2-no-ide</id>
    <content type="html"><![CDATA[<h1>Outline</h1>

<ol>
<li>Pre-requisites</li>
<li>Deploying Axis2</li>
<li>Writing the service class</li>
<li>Deploying the service</li>
<li>Verification</li>
</ol>


<h1>Pre-requisites</h1>

<p>We need Apache Axis2 running and a suitable container. You could also run Axis2 as a standalone server but for this let&rsquo;s use Tomcat as a container. So in the following order</p>

<ol>
<li>Download and install JDK7</li>
<li>Download and install Tomcat 7 (even 8 would do, but it seems as of now Tomcat 8 isn&rsquo;t being supported by Eclipse, so let&rsquo;s go with v7)</li>
<li>Download and install AXis2 on Tomcat</li>
</ol>


<h2>JDK7</h2>

<p>Download and extract the JDK tarball.</p>

<p><code>bash
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/7u60-b19/jdk-7u60-linux-x64.tar.gz
tar zxvf jdk-7u60-linux-x64.tar.gz
</code>
Add and modify the following lines in ~/.profile or /etc/profile (for system wide application) to add <code>JAVA_HOME</code> environment variable and it&rsquo;s bin folder to <code>$PATH</code>.</p>

<p><code>bash
export JAVA_HOME=/path/to/jdk/extraction
export PATH=$PATH:$HOME/bin:$JAVA_HOME/bin
</code></p>

<p>Refresh the terminal session and check if Java is working</p>

<p><code>bash
source ~/.profile
java -version
</code></p>

<h2>Tomcat 7</h2>

<p>You could install tomcat through <code>apt-get</code> or manually.</p>

<p><code>bash
sudo apt-get install tomcat7
</code></p>

<p>Or download and set paths manually.</p>

<p><code>bash
wget http://supergsego.com/apache/tomcat/tomcat-7/v7.0.54/bin/apache-tomcat-7.0.54.tar.gz
tar zxvf apache-tomcat-7.0.54.tar.gz
mv apache-tomcat-7.0.54 ~/dev/
</code></p>

<p>Add the <code>$CATALINA_HOME</code> env var to the bash profile.</p>

<p><code>bash
vi ~/.profile
</code></p>

<p>Prepend the following line before exporting the $PATH.</p>

<p><code>bash
export CATALINA_HOME=$HOME/dev/apache-tomcat-7.0.54
</code></p>

<p>Server start/stop can be done by the scripts in the <code>$CATALINA_HOME/bin</code> folder.</p>

<p><code>bash
cd $CATALINA_HOME
./bin/startup.sh
</code></p>

<h1>Deploying Axis2</h1>

<p>Download Axis2 WAR distribution and copy the web archive file to the tomcat webapps root.</p>

<p><code>bash
wget http://apache.tradebit.com/pub//axis/axis2/java/core/1.6.2/axis2-1.6.2-war.zip
unzip axis2-1.6.2-war.zip -d axis2-war
cp axis2-war/axis2.war $CATALINA_HOME/webapps/
cd $CATALINA_HOME/bin
./shutdown.sh
./startup.sh
</code></p>

<p>In the browser go to <a href="http://localhost:8080/axis2">http://localhost:8080/axis2</a>. Axis2 welcome page should appear.</p>

<h1>The Service</h1>

<p>An Axis2 archive (of <code>.aar</code> extension) has a certain directory structure not so different from a Web Archive.</p>

<p>``` bash Axis2 Archive Directory Structure start:1 linenos:false mark:4,9
.
├── SimpleService</p>

<pre><code>└─── META-INF
  └─── services.xml
└── com
  └─── chamiladealwis
    └─── ws
      └─── service
        └─── SimpleService.java
</code></pre>

<p>```</p>

<p>META-INF folder contains the services descriptor file. The other is the binary which implements the service.</p>

<p>The service class itself is a plain old Java class which exposes the services it offers through public methods. My simple service would be the following.</p>

<p>``` java SimpleService.java
package com.chamiladealwis.ws.service;</p>

<p>public class SimpleService
{</p>

<pre><code>public int add(int num1, int num2)
{
    return num1+num2;
}
</code></pre>

<p>}
```</p>

<p><code>SimpleService</code> offers just one service  named <code>add</code> which accepts two Integer parameters and returns the sum of them as an Integer.</p>

<p>Now this service needs a service descriptor which exposes the service class to Axis2 when asked.</p>

<p>``` xml services.xml mark:3
<service></p>

<pre><code>&lt;parameter name="ServiceClass" locked="false"&gt;
    com.chamiladealwis.ws.service.SimpleService
&lt;/parameter&gt;
&lt;operation name="sayHello"&gt;
    &lt;messageReceiver class="org.apache.axis2.rpc.receivers.RPCMessageReceiver" /&gt;
&lt;/operation&gt;
</code></pre>

<p></service>
<code>``
A parameter named</code>ServiceClass<code>is defined with value</code>com.chamiladealwis.ws.service.SimpleService` which the FQN of the Java class we just wrote.</p>

<p>Now compile sources, create the Axis2 archive and deploy it in the Axis Server.</p>

<p>``` bash</p>

<h1>go to the root dir and compile the sources</h1>

<p>javac com/chamiladealwis/ws/service/*.java</p>

<h1>create the archive file</h1>

<p>jar cvf SimpleService.aar *</p>

<h1>copy the archive over to the Axis2 web root</h1>

<p>cp SimpleService.aar $CATALINE_HOME/webapps/axis2/WEB-INF/services/</p>

<h1>restart tomcat</h1>

<p>cd $CATALINA_HOME/bin
./shutdown.sh
./startup.sh
```</p>

<p>Browse to <a href="http://localhost:8080/axis2/services/listServices">http://localhost:8080/axis2/services/listServices</a> in your browser and you will see <code>SimpleService</code> being listed as an availble service with <code>add</code> as an operation.</p>

<p>Click on the link to <code>SimpleService</code> to view the WSDL file which will describe the service and it&rsquo;s operation in an abstracted XML interpretation that can be used to create clients in any language to consume the service.</p>

<h1>The Client</h1>

<p>The client code has to make use of a &ldquo;Stub&rdquo; of the service which will act as a proxy and a communication agent. Axis2 binary distribution includes tools which can generate the Java stub using the WSDL file as the source.</p>

<p>Download the Axis2 binary distribution, extract it and set <code>AXIS2_HOME</code> environment variable to its root. Add <code>$AXIS2_HOME</code> to <code>$PATH</code>.</p>

<p><code>bash
wget http://apache.spinellicreations.com//axis/axis2/java/core/1.6.2/axis2-1.6.2-bin.zip
unzip axis2-1.6.2-bin.zip
pwd
</code></p>

<p>Add the <code>$AXIS2_HOME</code> variable before <code>export PATH</code> line and modify <code>$PATH</code> to include <code>$AXIS2_HOME/bin</code>.</p>

<p><code>bash
export AXIS2_HOME=/path/to/axis2/binary/folder
export PATH="$PATH:$AXIS2_HOME/bin"
</code></p>

<p>Now refresh terminal by sourcing the .profile file.</p>

<p><code>bash
source ~/.profile
echo $AXIS2_HOME
</code></p>

<p>Copy the WSDL path of the <code>SimpleService</code>, go to the directory you&rsquo;re going to create your client code and execute the following.</p>

<p><code>bash
./wsdl2java.sh -uri WSDL_PATH_OF_THE_SIMPLESERVICE -o client
</code></p>

<p>The WSDL path would be something similar to <code>http://localhost:8080/axis2/services/SimpleService?wsdl</code>.</p>

<p>This will create the Java stub and the CallbackHandler classes. The CallbackHandler class can be extended to implement custom success and error callback executions. The Stub is the class of main importance here. It contains the Request and Response types of the operations available from the Service it was generated from and the skeletol methods that call to the target endpoint once invoked. We will use these members to call our simple service.</p>

<p>```java SimpleServiceClient.java
package com.chamiladealwis.ws.client;</p>

<p>import java.rmi.RemoteException;</p>

<p>import org.apache.axis2.AxisFault;</p>

<p>import com.chamiladealwis.ws.client.SimpleServiceStub.Add;
import com.chamiladealwis.ws.client.SimpleServiceStub.AddResponse;</p>

<p>public class SimpleClient
{</p>

<pre><code>public static void main(String[] args) 
{
    try 
    {
        // Create the Stub object
        SimpleServiceStub serviceStub = new SimpleServiceStub();

        // Create the Request object. The request class is autogenerated
        // as an inner class of the Stub class.
        Add addReq = new Add();

        // Set parameters
        addReq.setNum1(4);
        addReq.setNum2(8);

        // Invoke method and get response as a response object
        AddResponse response = serviceStub.add(addReq);

        // Response object's get_return() returns the return of the remote 
        // method
        int sum = response.get_return();
        System.out.println("Sum : " + sum);
    } 
    catch (AxisFault e) 
    {
        e.printStackTrace();
    } 
    catch (RemoteException e) 
    {
        e.printStackTrace();
    }        
}
</code></pre>

<p>}
```</p>

<p>Let&rsquo;s go through the client code.</p>

<p>Consuming an operation available through a Web Service consists of following steps.</p>

<ul>
<li>Create an object of the stub. All method calls will be invoked through this object.
<code>java
SimpleServiceStub serviceStub = new SimpleServiceStub();
</code></li>
<li>Create the request object. This will have methods to add input parameters to the request.
<code>java
Add addReq = new Add();
addReq.setNum1(4);
addReq.setNum2(8);
</code></li>
<li>Invoke and the operation method. The operation method will be invoked through the stub object and the invocation accepts a parameter of type of request object.
<code>java
serviceStub.add(addReq);
</code></li>
<li>Catch the response object. The invocation will return the response object mainly containing the value returned by the operation.
<code>java
AddResponse response = serviceStub.add(addReq);
</code></li>
<li>Extract the return value. By calling <code>get_return()</code> of the response object the return value can be extracted.
<code>java
int sum = response.get_return();
</code></li>
</ul>


<p>As you see it&rsquo;s pretty straightforward, although there are couple of things to keep in mind.</p>

<ol>
<li>You have to regenerate the client stubs everytime you change most of the server code (obviously).</li>
<li>It&rsquo;s good to check if the service has been properly deployed by going to the services page and checking the WSDL generation.</li>
<li>This was a <em>simple</em> client with <em>simple</em> input and output types. When complex types are involved there are some standards to be practiced. Be mindful that Web Services operate on a language and platform agnostic environment.</li>
<li><em>You will not be writing web services and clients this way most of the time!</em> But that&rsquo;s a topic for another post :)</li>
</ol>

]]></content>
  </entry>
  
</feed>
