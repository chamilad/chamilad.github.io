<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apache activemq | nuts!]]></title>
  <link href="http://chamilad.github.io/blog/categories/apache-activemq/atom.xml" rel="self"/>
  <link href="http://chamilad.github.io/"/>
  <updated>2016-02-10T13:09:00+05:30</updated>
  <id>http://chamilad.github.io/</id>
  <author>
    <name><![CDATA[chamila]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating a Simple ActiveMQ Master/Slave Setup]]></title>
    <link href="http://chamilad.github.io/blog/2015/11/17/creating-a-simple-activemq-master-slash-slave-setup/"/>
    <updated>2015-11-17T17:11:12+05:30</updated>
    <id>http://chamilad.github.io/blog/2015/11/17/creating-a-simple-activemq-master-slash-slave-setup</id>
    <content type="html"><![CDATA[<p>ActiveMQ is a high performing message broker, however if clustering is needed, it supports <a href="http://activemq.apache.org/clustering.html">a number of methods</a>. Out of these, the <a href="http://activemq.apache.org/masterslave.html">Master/Slave</a> is a pattern where the persistence layer is shared between multiple broker instances. A Single <code>Master</code> broker connects to the persistence, and the rest of the <code>Slave</code> brokers keep waiting to attain the lock on the persistence. If the Master node goes down the lock for the persistence is released and a Slave quickly acquires it, allowing a client to continue operation without any data loss. The clients should connect to the Master/Slave setup, using the <code>failover:</code> transport, or they should implement a manual failover mechanism to automatically connect to the next available broker when the first one goes down.</p>

<p><code>properties
connectionfactoryName=TopicConnectionFactory
java.naming.provider.url=failover:(tcp://localhost:61617,tcp://localhost:61618,tcp://localhost:61619)?initialReconnectDelay=100
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
</code></p>

<h1>How to Setup a Master/Slave</h1>

<p>Let&rsquo;s setup two broker instances in the same machine. The two instances will open different ports for the protocols, so there will be no conflicts. They will use the flat file based embedded KahaDB as the persistence layer and the two instances will share the KahaDB instance.</p>

<h2>Creating Two Broker Instances</h2>

<p>Unzip the ActiveMQ distribution to two places and offset port values in the second one to use different ports so that there will be no conflicts for ports used by the different protocol connectors. The places to change are in <code>&lt;ACTIVEMQ_HOME&gt;/conf/activemq.xml</code> and <code>&lt;ACTIVEMQ_HOME&gt;/conf/jetty.xml</code>.</p>

<p>```xml activemq.xml
<transportConnectors></p>

<pre><code>&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;
&lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61626?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;transportConnector name="amqp" uri="amqp://0.0.0.0:5682?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;transportConnector name="stomp" uri="stomp://0.0.0.0:61623?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;transportConnector name="mqtt" uri="mqtt://0.0.0.0:1893?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;transportConnector name="ws" uri="ws://0.0.0.0:61624?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
</code></pre>

<p></transportConnectors>
```</p>

<p><code>xml jetty.xml
&lt;bean id="jettyPort" class="org.apache.activemq.web.WebConsolePort" init-method="start"&gt;
  &lt;!-- the default port number for the web console --&gt;
  &lt;property name="host" value="0.0.0.0"/&gt;
  &lt;property name="port" value="8171"/&gt;
&lt;/bean&gt;
</code></p>

<p>Now let&rsquo;s point the KahaDB persistence to the same location. This will result in only one instance at a time being able to acquire the lock to the DB and when the lock is released the other instance will be able get it from the same location.</p>

<p>Modify the <code>persistenceAdapter</code> tag inside <code>&lt;ACTIVEMQ_HOME&gt;/conf/activemq.xml</code> as follows.</p>

<p>```xml
<persistenceAdapter></p>

<pre><code>&lt;kahaDB directory="/tmp/mq/kahadb"/&gt;
</code></pre>

<p></persistenceAdapter>
```</p>

<p>Do this change for both of the instances.</p>

<p>Now, let&rsquo;s introduce the two instances to each other by adding a <code>networkConnector</code> pointing to each other. Add the following block to the <code>&lt;ACTIVEMQ_HOME&gt;/conf/activemq.xml</code> after the <code>persistenceAdapter</code> block in the master.</p>

<p>```xml
<networkConnectors></p>

<pre><code>&lt;networkConnector uri="static:(tcp://localhost:61626)" /&gt;
</code></pre>

<p></networkConnectors>
```</p>

<p>Port <code>61626</code> is the OpenWire port in the Slave instance. Similarly add the same block in the Slave <code>activemq.xml</code> file, pointing to the Master&rsquo;s OpenWire port. Static discovery is used here to statically point to the existing broker instances.</p>

<h2>Starting the instances</h2>

<p>Now let&rsquo;s start the Master broker instance.</p>

<p>```bash
cd &lt;ACTIVEMQ_HOME>/bin
./activemq start</p>

<h1>tail the logs just for the fun of it</h1>

<p>tail -100f ../data/activemq.log
```</p>

<p>When observing the logs you will see some log entries similar to the following repeatedly appearing.</p>

<p>```
2015-11-17 19:10:19,731 | INFO  | Establishing network connection from vm://localhost?async=false&amp;network=true to tcp://localhost:61626 | org.apache.activemq.network.DiscoveryNetworkConnector | ActiveMQ Task-61
2015-11-17 19:10:19,733 | INFO  | Connector vm://localhost started | org.apache.activemq.broker.TransportConnector | ActiveMQ Task-61
2015-11-17 19:10:19,736 | INFO  | localhost Shutting down | org.apache.activemq.network.DemandForwardingBridgeSupport | ActiveMQ BrokerService[localhost] Task-134
2015-11-17 19:10:19,738 | INFO  | localhost bridge to Unknown stopped | org.apache.activemq.network.DemandForwardingBridgeSupport | ActiveMQ BrokerService[localhost] Task-134
2015-11-17 19:10:19,739 | INFO  | Connector vm://localhost stopped | org.apache.activemq.broker.TransportConnector | ActiveMQ Task-61
2015-11-17 19:10:19,741 | WARN  | Could not start network bridge between: vm://localhost?async=false&amp;network=true and: tcp://localhost:61626 due to: Connection refused | org.apache.activemq.network.DiscoveryNetworkConnector | ActiveMQ Task-61</p>

<p>```</p>

<p>This is because we &ldquo;introduced&rdquo; the Slave broker to the Master broker and now it&rsquo;s looking for it.</p>

<p>Now start the Slave broker and tail the logs. You will see a different set of logs appearing.</p>

<p>```
2015-11-17 18:34:37,359 | INFO  | Database /tmp/mq/kahadb/lock is locked&hellip; waiting 10 seconds for the database to be unlocked. Reason: java.io.IOException: File &lsquo;/tmp/mq/kahadb/lock&rsquo; could not be locked. | org.apache.activemq.store.SharedFileLocker | main</p>

<p>```</p>

<p>This is because the lock for the shared DB is already acquired by the Master broker. The Slave broker will not start until it is able to acquire the lock for the DB. If you try to see which ports are open using the <code>netstat</code> command you will see that only the Master broker is up and running and ready to accept requests.</p>

<p>Now if you connect to the broker setup using the <code>failover:</code> transport you will see that the client connected the Master broker. Create a queue and publish an event to the queue without consuming it. Now stop the Master broker. You will see the Slave broker acquiring the lock to the DB and become ready to accept requests. Start a consumer with the <code>failover</code> transport and observe it connecting to and retrieving the event (which was published to the Master broker) from the Slave broker. There was no data loss and the service didn&rsquo;t stop responding for more than a few moments which the Slave took to start up after acquiring the DB lock.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Support for ActiveMQ Master/Slave failover in Apache Stratos Cartridge Agent]]></title>
    <link href="http://chamilad.github.io/blog/2015/11/16/support-for-activemq-master-slash-slave-failover-in-apache-stratos-cartridge-agent/"/>
    <updated>2015-11-16T20:20:07+05:30</updated>
    <id>http://chamilad.github.io/blog/2015/11/16/support-for-activemq-master-slash-slave-failover-in-apache-stratos-cartridge-agent</id>
    <content type="html"><![CDATA[<p>In Apache Stratos the message broker is a crucial point of operation upon which all components depend on. Recent Stratos releases included fixes to <a href="http://code.chamiladealwis.com/blog/2015/10/11/secure-message-broker-communication-in-apache-stratos/">secure the message broker communication</a>. The upcoming 4.1.5 release will contain a missing improvement for the Python Cartridge Agent related to message broker communication.</p>

<p>ActiveMQ supports <a href="http://activemq.apache.org/clustering.html">various types of clustering patterns</a>. Out of these, <a href="http://activemq.apache.org/masterslave.html">Master/Slave</a> is a deployment pattern where the message store is replicated or shared between the clustered brokers. This makes it possible for a client to failover from the <code>master</code> to the <code>slave</code> in case the master broker goes down, and continue the communication without any data loss.</p>

<p>Earlier, the Cartridge Agent implementation was in Java and the ActiveMQ client used in Apache Stratos allowed the failover transport to be used right out of the box, by using the <code>failover</code> transport in the JNDI configuration.</p>

<p><code>properties
connectionfactoryName=TopicConnectionFactory
java.naming.provider.url=failover:(tcp://localhost:61617,tcp://localhost:61618,tcp://localhost:61619)?initialReconnectDelay=100
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
</code></p>

<p>However when the Python implementation of the Cartridge Agent was done this support was not implemented initially. Therefore, it was only possible for Python Cartridge Agent to connect to only one given message broker making it a possible point of failure.</p>

<p>However the upcoming 4.1.5 release contains the fix for the Python Cartridge Agent which enables it to accept a list of message brokers. This is provided via the <code>agent.conf</code> configuration file as follows.</p>

<p><code>ini
[agent]
mb.urls                               =localhost:1885,localhost:1886,localhost:1887
mb.username                           =system
mb.password                           =manager
mb.publisher.timeout                  =900
</code></p>

<p>The crucial change is from <code>mb.username</code> and <code>mb.password</code> to <code>mb.urls</code>. This will be a comma separated list of host:port values of the available broker list.</p>

<p>When communicating with the message broker, the Python Cartridge Agent will go through the provided URL list and connect to the first broker that is available.</p>

<p>The listening subscriber client will always make an effort to keep a connection to one of the brokers. i.e. if the connected broker goes down (the Python Cartridge Agent will periodically check if the connected message broker is in fact alive or not), it will go through the message broker list and select the first available broker. If none of the provided message brokers are online, the subscribing client will keep retrying until one broker becomes available. This logic will separately execute for each topic subscription.</p>

<p>The publishing client will publish the events to the first broker available. If none of the brokers are available it will keep retrying to publish the event, until the provided <code>mb.publisher.timeout</code> value is exceeded. The default value for this is 15 minutes. After that timeout, if the event is still unpublished, it will be dropped, and life moves on.</p>

<p>Notice that it will be possible for the events to be published to one broker and intended consumers to be connected to another. However, if the Master/Slave deployment is done correctly data sharing happens without an issue and this situation shouldn&rsquo;t be of any concern.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Secure Message Broker Communication in Apache Stratos with Apache ActiveMQ]]></title>
    <link href="http://chamilad.github.io/blog/2015/10/11/secure-message-broker-communication-in-apache-stratos/"/>
    <updated>2015-10-11T00:55:36+05:30</updated>
    <id>http://chamilad.github.io/blog/2015/10/11/secure-message-broker-communication-in-apache-stratos</id>
    <content type="html"><![CDATA[<p>Apache Stratos relies heavily on message broker communication. In fact, message broker communication with message broker topics is the main method of communication between components such as the Cartridge Agent, Cloud Controller and the Autoscaler, as this allows a decoupled architecture for the components.</p>

<p><img src="/images/post_resource/stratos/ca-overview.png"></p>

<p>When it comes to message brokers, authentication is a crucial part of securing the communication channel since if left unsecured, anyone with access to the message broker can subscribe to the topics and listen to the communication between the components. This can expose sensitive data easily and the system would be compromised in no time. The purpose of this article is to explain how to engage Username and Password based authentication with Apache ActiveMQ in Stratos.</p>

<h1>Securing ActiveMQ</h1>

<p>ActiveMQ allows to add authentication and authorization through an extensible plugin system. For our purpose, the out of the box <code>SimpleAuthenticationPlugin</code> is more than enough as it allows us to define a username and a password with the list of user groups the particular user belongs to.</p>

<p>To engage <code>SimpleAuthenticationPlugin</code> we have to add the following section before the <code>broker</code> tag closes, in <code>&lt;ACTIVEMQ_HOME&gt;/conf/activemq.xml</code>.</p>

<p>```xml
<plugins></p>

<pre><code>&lt;simpleAuthenticationPlugin&gt;
    &lt;users&gt;
        &lt;authenticationUser username="system" password="manager" groups="users,admins"/&gt;
    &lt;/users&gt;
&lt;/simpleAuthenticationPlugin&gt;
</code></pre>

<p></plugins>
```</p>

<p>As you can see we have introduced a user named <code>system</code> with password <code>manager</code> who belongs to groups <code>users</code> and <code>admins</code>. Since we have not allowed anonymous access, any subscriber or a publisher that connects to ActiveMQ should provide these credentials to successfully communicate. We can enable anonymous access by specifying the <code>allowAnonymousAccess</code> attribute on <code>simpleAuthenticationPlugin</code> to <code>true</code>.</p>

<p>After the configuration file is saved, restart ActiveMQ.</p>

<h1>Providing Credentials on Stratos</h1>

<p>Within Stratos there are three configurations that we have to provide message broker credentials in to.</p>

<h2>Stratos Components &ndash; Cloud Controller, Autoscaler, Stratos Manager</h2>

<p>The ActiveMQ credentials for Stratos components can be provided by the <code>jndi.properties</code> file. Simply add the following two lines in the <code>&lt;STRATOS_HOME&gt;/repository/conf/jndi.properties</code> file.</p>

<p><code>
java.naming.security.principal=system
java.naming.security.credentials=manager
</code></p>

<p><code>java.naming.security.principal</code> corresponds to the ActiveMQ username and <code>java.naming.security.credentials</code> contains the password.</p>

<h2>Complex Event Processor</h2>

<p>Based on the health statistics published from the instances via <a href="http://code.chamiladealwis.com/blog/2014/10/10/thrift-communication-in-apache-stratos/">Thrift</a>, the Complex Event Processor publishes several crucial messages to the message broker. This is done using a JMSOutputAdaptor. To configure the JMSOutputAdaptor to use ActiveMQ credentials, add the following entries inside the <code>outputEventAdaptor</code> tag, in the configuration file at   <code>&lt;STRATOS_HOME&gt;/repository/deployment/server/outputeventadaptors/JMSOutputAdaptor.xml</code></p>

<p><code>xml
&lt;property name="transport.jms.UserName"&gt;system&lt;/property&gt;
&lt;property name="transport.jms.Password"&gt;manager&lt;/property&gt;
</code></p>

<h2>Cartridge Agent</h2>

<p>The Python Cartridge Agent can be configured with ActiveMQ credentials by specifying the <code>mb.username</code> and <code>mb.password</code> options in the <code>agent.conf</code> file.</p>

<p>To do this in a Docker image managed by Kubernetes, specify the following options in the Kubernetes Cluster Configuration JSON file, under the <code>property</code> array.</p>

<p><code>json
{
  "name": "payload_parameter.MB_USERNAME",
  "value": "system"
},
{
  "name": "payload_parameter.MB_PASSWORD",
  "value": "manager"
}
</code></p>

<p>For a VM, these values can be specified in the <code>base.pp</code> manifest in the Puppet server.</p>

<p><code>puppet
$mb_username          = 'system'
$mb_password          = 'manager'
</code></p>

<p>After the credentials are enabled and configured, if anonymous access is not allowed, no external user without the credentials will not be able to listen to the communication or publish messages on the message broker.</p>
]]></content>
  </entry>
  
</feed>
